<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>是方圆啊</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-12T07:09:38.943Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>匡媛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈TypeScript</title>
    <link href="http://example.com/2021/04/15/%E6%B5%85%E8%B0%88TypeScript/"/>
    <id>http://example.com/2021/04/15/%E6%B5%85%E8%B0%88TypeScript/</id>
    <published>2021-04-15T03:12:21.000Z</published>
    <updated>2021-03-12T07:09:38.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="1-1-TS简介"><a href="#1-1-TS简介" class="headerlink" title="1.1 TS简介"></a>1.1 TS简介</h2><p>TypeScript 是 JavaScript 的强类型版本。然后在编译期去掉类型和特有语法，生成纯粹的 JavaScript 代码。由于最终在浏览器中运行的仍然是 JavaScript，所以 TypeScript 并不依赖于浏览器的支持，也并不会带来兼容性问题。</p><p>TypeScript 是 JavaScript 的超集，这意味着他支持所有的 JavaScript 语法。并在此之上对 JavaScript 添加了一些扩展，如 class / interface / module 等。这样会大大提升代码的可阅读性。</p><p>和 JavaScript 弱类型不同，TypeScript 这种强类型语言最大的优势在于静态类型检查，可以在代码开发阶段就预知一些低级错误的发生。</p><ul><li>一种类似于 JavaScript 的语言，在 JavaScript 的基础之上增加了类型，同时增强了 JavaScript 部分语法功能</li><li>遵循 EcmaScript 6 标准规范</li><li>由微软开发</li><li>Angular 2 框架采用 TypeScript 编写</li><li>背后有微软和谷歌两大公司的支持</li><li>TypeScript 可以编译成 JavaScript 从而在支持 JavaScript 的环境中运行</li><li>TypeScript 和 JavaScript 的关系就好比 less 和 css 的关系</li></ul><p>TypeScript 中文网 <a href="https://www.tslang.cn/">https://www.tslang.cn/</a></p><p>在线编译环境 <a href="https://www.typescriptlang.org/play/index.html">https://www.typescriptlang.org/play/index.html</a></p><h2 id="1-2-TS环境搭建"><a href="#1-2-TS环境搭建" class="headerlink" title="1.2 TS环境搭建"></a>1.2 TS环境搭建</h2><ol><li>打开命令行，键入<code>npm i -g typescript</code> 全局安装TS</li><li>继续在命令行环境下键入 <code>tsc -init</code> 进行初始化，<br>你会发现根目录下多了 tsconfig.json 的文件，记录了编译成JS的选项</li><li>创建ts文件</li><li>打开VSCode进入该目录，按下 Ctrl+shift+B 快捷键会进行编译，初次编译会选择编译模式</li><li>输入node命令运行js代码</li></ol><h2 id="1-3-变量声明"><a href="#1-3-变量声明" class="headerlink" title="1.3 变量声明"></a>1.3 变量声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">var</span><br><span class="line">- 作用域 : 全局作用域、函数作用域</span><br><span class="line">- 重复声明</span><br><span class="line">- 变量提升</span><br><span class="line"></span><br><span class="line">let</span><br><span class="line">- 块级作用域</span><br><span class="line">- 在同一个块中不能重复声明</span><br><span class="line"></span><br><span class="line">const</span><br><span class="line">- 声明同时必须赋值</span><br><span class="line">- 一旦声明不可改变（对象可以修改）</span><br><span class="line">- 块级作用域</span><br></pre></td></tr></table></figure><h2 id="1-4-基本数据类型"><a href="#1-4-基本数据类型" class="headerlink" title="1.4 基本数据类型"></a>1.4 基本数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;字符串</span><br><span class="line">var uname:string &#x3D; &quot;zhangsan&quot;;</span><br><span class="line">let nickname: string &#x3D; &#39;张三&#39;;</span><br><span class="line">let isDone: boolean &#x3D; false;</span><br><span class="line">let age: number &#x3D; 37;</span><br><span class="line">let sentence: string &#x3D; &#96;Hello, my nickname is $&#123; nickname &#125;.</span><br><span class="line"></span><br><span class="line">I&#39;ll be $&#123; age + 1 &#125; years old next month.&#96;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;数组</span><br><span class="line">&#x2F;&#x2F;TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组：</span><br><span class="line">let list: number[] &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</span><br><span class="line">let list: Array&lt;number&gt; &#x3D; [1, 2, 3];</span><br><span class="line">Javascript</span><br><span class="line">&#x2F;&#x2F;ts的数组只能存放单一数据类型的元素，元组则可以很好的解决此问题。</span><br><span class="line">&#x2F;&#x2F;元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为string和number类型的元组。</span><br><span class="line">&#x2F;&#x2F; Declare a tuple type</span><br><span class="line">let x: [string, number];</span><br><span class="line">&#x2F;&#x2F; Initialize it</span><br><span class="line">x &#x3D; [&#39;hello&#39;, 10]; &#x2F;&#x2F; OK</span><br><span class="line">&#x2F;&#x2F; Initialize it incorrectly</span><br><span class="line">x &#x3D; [10, &#39;hello&#39;]; &#x2F;&#x2F; Error</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;object类型</span><br><span class="line">- 允许赋任意值</span><br><span class="line">- 但是不能调用任意方法，即便它真的有</span><br><span class="line"></span><br><span class="line">let foo: object &#x3D; &#123;</span><br><span class="line">  name: &#39;Jack&#39;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;知道即可，用的很少，没有类型校验和语法提示</span><br><span class="line">Javascript</span><br><span class="line">&#x2F;&#x2F;Any</span><br><span class="line">&#x2F;&#x2F;有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</span><br><span class="line"></span><br><span class="line">let notSure: any &#x3D; 4;</span><br><span class="line">notSure &#x3D; &quot;maybe a string instead&quot;;</span><br><span class="line">notSure &#x3D; false; &#x2F;&#x2F; okay, definitely a boolean</span><br><span class="line">Javascript</span><br><span class="line">&#x2F;&#x2F;Void 类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</span><br><span class="line"></span><br><span class="line">function warnUser(): void &#123;</span><br><span class="line">  alert(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined：</span><br><span class="line">let unusable: void &#x3D; undefined;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;Null 和 Undefined</span><br><span class="line">&#x2F;&#x2F; Not much else we can assign to these variables!</span><br><span class="line">let u: undefined &#x3D; undefined;</span><br><span class="line">let n: null &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;never</span><br><span class="line">never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</span><br><span class="line">let x: never;</span><br><span class="line">let y: number;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行错误，数字类型不能转为 never 类型</span><br><span class="line">x &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F; 运行正确，never 类型可以赋值给 never类型</span><br><span class="line">x &#x3D; (()&#x3D;&gt;&#123; throw new Error(&#39;exception&#39;)&#125;)();</span><br><span class="line">&#x2F;&#x2F; 运行正确，never 类型可以赋值给 数字类型</span><br><span class="line">y &#x3D; (()&#x3D;&gt;&#123; throw new Error(&#39;exception&#39;)&#125;)();</span><br><span class="line">&#x2F;&#x2F; 返回值为 never 的函数可以是抛出异常的情况</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 返回值为 never 的函数可以是无法被执行到的终止点的情况</span><br><span class="line">function loop(): never &#123;</span><br><span class="line">    while (true) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;类型推断</span><br><span class="line">&#x2F;&#x2F; 有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类型断言有两种形式。 其一是“尖括号”语法：</span><br><span class="line"></span><br><span class="line">let someValue: any &#x3D; true;</span><br><span class="line">let strLength: number &#x3D; (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;另一个为as语法：</span><br><span class="line">let someValue: any &#x3D; &quot;this is a string&quot;;</span><br><span class="line">let strLength: number &#x3D; (someValue as string).length;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;枚举类型</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red, Green, Blue&#125;;</span><br><span class="line">let c: Color &#x3D; Color.Blue;</span><br><span class="line">console.log(c);    &#x2F;&#x2F; 输出 2</span><br></pre></td></tr></table></figure><h2 id="1-5-解构赋值"><a href="#1-5-解构赋值" class="headerlink" title="1.5 解构赋值"></a>1.5 解构赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;数组解构</span><br><span class="line">let input &#x3D; [1, 2];</span><br><span class="line">let [first, second] &#x3D; input;</span><br><span class="line">console.log(first); &#x2F;&#x2F; outputs 1</span><br><span class="line">console.log(second); &#x2F;&#x2F; outputs 2</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;上面的写法等价于：</span><br><span class="line">first &#x3D; input[0];</span><br><span class="line">second &#x3D; input[1];</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;利用解构赋值交换变量：</span><br><span class="line">[first, second] &#x3D; [second, first];</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;函数参数解构：</span><br><span class="line">&#x2F;&#x2F;函数参数解构：</span><br><span class="line">function ff([first, second]: [number, number]) &#123; </span><br><span class="line">  console.log(first)</span><br><span class="line">  console.log(second)</span><br><span class="line">&#125;</span><br><span class="line">ff([1,2])</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;解构剩余参数：</span><br><span class="line">let [first, ...rest] &#x3D; [1, 2, 3, 4]</span><br><span class="line">console.log(first) &#x2F;&#x2F; 1</span><br><span class="line">console.log(rest) &#x2F;&#x2F; [2, 3, 4]</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;也可以忽略其它参数：</span><br><span class="line">let [first] &#x3D; [1, 2, 3, 4];</span><br><span class="line">console.log(first); &#x2F;&#x2F; outputs 1</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;或者跳过解构：</span><br><span class="line">let [, second, , fourth] &#x3D; [1, 2, 3, 4]</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;对象解构</span><br><span class="line">let o &#x3D; &#123;</span><br><span class="line">    a: &quot;foo&quot;,</span><br><span class="line">    b: 12,</span><br><span class="line">    c: &quot;bar&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;let &#123; a, b &#125; &#x3D; o;</span><br><span class="line">&#x2F;&#x2F;let &#123;a, b&#125;: &#123;a: string, b: number&#125; &#x3D; o;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;你可以在对象里使用 ... 语法创建剩余变量：</span><br><span class="line">let &#123; a, ...passthrough &#125; &#x3D; o;</span><br><span class="line">let total &#x3D; passthrough.b + passthrough.c.length;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;属性解构重命名</span><br><span class="line">&#x2F;&#x2F;你也可以给属性以不同的名字：</span><br><span class="line">let &#123; a: newName1, b: newName2 &#125; &#x3D; o;</span><br></pre></td></tr></table></figure><h2 id="1-6-展开操作符-…"><a href="#1-6-展开操作符-…" class="headerlink" title="1.6 展开操作符 (…)"></a>1.6 展开操作符 (…)</h2><ul><li>展开数组</li><li>展开对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Javascript</span><br><span class="line">let arr1 &#x3D; [1, 2, 3];</span><br><span class="line">let arr2 &#x3D; [4, 5, 6];</span><br><span class="line">let arr3 &#x3D; [...arr1, ...arr2];</span><br><span class="line"></span><br><span class="line">let obj1 &#x3D; &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let obj2 &#x3D; &#123; c: 3 &#125;</span><br><span class="line">let obj3 &#x3D; &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line">console.log(arr3,obj3)</span><br></pre></td></tr></table></figure><h2 id="1-7-函数"><a href="#1-7-函数" class="headerlink" title="1.7 函数"></a>1.7 函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;函数参数</span><br><span class="line">&#x2F;&#x2F;参数及返回值类型</span><br><span class="line">&#x2F;&#x2F;function 函数名字(参数1,参数2,参数3):函数返回值&#123;函数体&#125;</span><br><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;可选参数</span><br><span class="line">function add(x: number, y?: number): number &#123;</span><br><span class="line">    return x + 10</span><br><span class="line">&#125;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;默认参数</span><br><span class="line">function add(x: number, y: number &#x3D; 20): number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;剩余参数</span><br><span class="line">function sum(...args: number[]): number &#123;</span><br><span class="line">    let ret: number &#x3D; 0</span><br><span class="line">    args.forEach((item: number): void &#x3D;&gt; &#123;</span><br><span class="line">        ret +&#x3D; item</span><br><span class="line">    &#125;)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(1, 2, 3)</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;箭头函数</span><br><span class="line">let add &#x3D; (x: number, y: number): number &#x3D;&gt; x + y</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;函数重载：重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数类型不同：</span><br><span class="line">function disp(string):void; </span><br><span class="line">function disp(number):void;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数数量不同：</span><br><span class="line">function disp(n1:number):void; </span><br><span class="line">function disp(x:number,y:number):void;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数类型顺序不同：</span><br><span class="line">function disp(n1:number,s1:string):void; </span><br><span class="line">function disp(s:string,n:number):void;</span><br></pre></td></tr></table></figure><h2 id="1-8-联合类型"><a href="#1-8-联合类型" class="headerlink" title="1.8 联合类型"></a>1.8 联合类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。</span><br><span class="line"></span><br><span class="line">var val:string|number </span><br><span class="line">val &#x3D; 12 </span><br><span class="line">val &#x3D; &quot;Runoob&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr:number[]|string[]; </span><br><span class="line">var i:number; </span><br><span class="line">arr &#x3D; [1,2,4] </span><br><span class="line">arr &#x3D; [&quot;Runoob&quot;,&quot;Google&quot;,&quot;Taobao&quot;]</span><br></pre></td></tr></table></figure><h2 id="1-9-类"><a href="#1-9-类" class="headerlink" title="1.9 类"></a>1.9 类</h2><h3 id="1-9-1-类的基本使用"><a href="#1-9-1-类的基本使用" class="headerlink" title="1.9.1 类的基本使用"></a>1.9.1 类的基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;基本示例</span><br><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    constructor(name: string, age: number) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let zs: Person &#x3D; new Person(&#39;张三&#39;, 18);</span><br></pre></td></tr></table></figure><h3 id="1-8-2-super关键字的使用"><a href="#1-8-2-super关键字的使用" class="headerlink" title="1.8.2 super关键字的使用"></a>1.8.2 super关键字的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;继承</span><br><span class="line">class Animal &#123;</span><br><span class="line">    move(distanceInMeters: number &#x3D; 0) &#123;</span><br><span class="line">        console.log(&#96;Animal moved $&#123;distanceInMeters&#125;m.&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        console.log(&#39;Woof! Woof!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog &#x3D; new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;下面是一个更复杂的例子：</span><br><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(theName: string) &#123; </span><br><span class="line">        this.name &#x3D; theName; </span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters: number &#x3D; 0) &#123;</span><br><span class="line">        console.log(&#96;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; </span><br><span class="line">        super(name); </span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters &#x3D; 5) &#123;</span><br><span class="line">        console.log(&quot;Slithering...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; </span><br><span class="line">        super(name); </span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters &#x3D; 45) &#123;</span><br><span class="line">        console.log(&quot;Galloping...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam &#x3D; new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">let tom: Animal &#x3D; new Horse(&quot;Tommy the Palomino&quot;);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个例子演示了如何在子类里可以重写父类的方法。 Snake类和 Horse类都创建了 move方法，它们重写了从Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法：</span><br><span class="line"></span><br><span class="line">Slithering...</span><br><span class="line">Sammy the Python moved 5m.</span><br><span class="line">Galloping...</span><br><span class="line">Tommy the Palomino moved 34m.</span><br></pre></td></tr></table></figure><h3 id="1-9-3-成员修饰符"><a href="#1-9-3-成员修饰符" class="headerlink" title="1.9.3 成员修饰符"></a>1.9.3 成员修饰符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;public 公共的</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    public constructor(theName: string) &#123; </span><br><span class="line">        this.name &#x3D; theName; </span><br><span class="line">    &#125;</span><br><span class="line">    public move(distanceInMeters: number) &#123;</span><br><span class="line">        console.log(&#96;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;private 私有的</span><br><span class="line">- 不能被外部访问，只能在类的内部访问使用</span><br><span class="line">- 私有成员不会被继承</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">  public age: number &#x3D; 18;</span><br><span class="line">  private type: string &#x3D; &#39;human&#39;</span><br><span class="line">  public constructor (name:string, age:number) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;protected 受保护的</span><br><span class="line">- 和 private 类似，但是可以被继承</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(name: string) &#123; </span><br><span class="line">        this.name &#x3D; name; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person &#123;</span><br><span class="line">    private department: string;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, department: string) &#123;</span><br><span class="line">        super(name)</span><br><span class="line">        this.department &#x3D; department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getElevatorPitch() &#123;</span><br><span class="line">        return &#96;Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.&#96;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let howard &#x3D; new Employee(&quot;Howard&quot;, &quot;Sales&quot;);</span><br><span class="line">console.log(howard.getElevatorPitch());</span><br><span class="line">console.log(howard.name); &#x2F;&#x2F; 错误</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意，我们不能在 Person类外使用 name，但是我们仍然可以通过 Employee类的实例方法访问，因为Employee是由 Person派生而来的。</span><br></pre></td></tr></table></figure><h3 id="1-9-4-getter和setter"><a href="#1-9-4-getter和setter" class="headerlink" title="1.9.4 getter和setter"></a>1.9.4 getter和setter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Javascript</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private _name:string;</span><br><span class="line"></span><br><span class="line">    constructor(name: string)</span><br><span class="line">    &#123;</span><br><span class="line">        this._name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set name(value:string) &#123;this._name &#x3D; value;&#125;</span><br><span class="line">    get name() &#123;return this._name;&#125;</span><br><span class="line"></span><br><span class="line">    talk()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;Hi, my name is &quot; + this.name + &quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-5-静态成员"><a href="#1-9-5-静态成员" class="headerlink" title="1.9.5 静态成员"></a>1.9.5 静态成员</h3><ul><li>不需要实例化访问的成员称之为静态成员，即只能被类访问的成员</li><li><code>static</code> 关键字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">class Person &#123;</span><br><span class="line">    &#x2F;&#x2F;静态变量</span><br><span class="line">    static country &#x3D; &quot;中国&quot;;</span><br><span class="line">    &#x2F;&#x2F;京塔方法</span><br><span class="line">    static sayhello() &#123; </span><br><span class="line">        console.log(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    constructor () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 &#x3D; new Person();  </span><br><span class="line">let p2 &#x3D; new Person(); </span><br><span class="line"></span><br><span class="line">console.log(Person.country)  &#x2F;&#x2F;静态变量，直接通过类型来访问</span><br><span class="line">console.log(p1.country) &#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure><h2 id="1-10-接口"><a href="#1-10-接口" class="headerlink" title="1.10 接口"></a>1.10 接口</h2><p>在面向对象编程中，接口是一种规范的定义，它定义了行为和动作规范，起到一种限制和规范的作用。<br>接口不关心状态数据，也不关心方法的实现细节，它只规定了一些属性和方法，而实现接口的类必须提供具体的信息。</p><h3 id="1-10-1-接口对类的规范"><a href="#1-10-1-接口对类的规范" class="headerlink" title="1.10.1 接口对类的规范"></a>1.10.1 接口对类的规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;定义一个人的接口</span><br><span class="line">interface Human &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    say(word: string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;让老师类实现Human接口，老师类实现接口的时候必须提供接口的具体信息</span><br><span class="line">class Teacher implements Human&#123;</span><br><span class="line">    name &#x3D; &quot;老师&quot;;</span><br><span class="line">    age &#x3D; 38;</span><br><span class="line">    say(word: string): void &#123;</span><br><span class="line">        console.log(&quot;老师说&quot;+word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;让学生类实现Human接口，学生类实现接口的时候必须提供接口的具体信息</span><br><span class="line">class Student implements Human&#123;</span><br><span class="line">    name &#x3D; &quot;学生&quot;;</span><br><span class="line">    age &#x3D; 18;</span><br><span class="line">    say(word: string): void &#123;</span><br><span class="line">         console.log(&quot;学生说&quot;+word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-2-接口对对象的规范"><a href="#1-10-2-接口对对象的规范" class="headerlink" title="1.10.2 接口对对象的规范"></a>1.10.2 接口对对象的规范</h3><p>TypeScript 中的接口除了可用于对类的一部分行为进行抽象以外，也常用于对对象的形状（Shape）进行描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Javascript</span><br><span class="line">interface Shape &#123;</span><br><span class="line">    head: string;</span><br><span class="line">    arm: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    shape: Shape;</span><br><span class="line">    say(word: string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jack: Person &#x3D; &#123;</span><br><span class="line">    name: &#39;Jack&#39;,</span><br><span class="line">    age: 18,</span><br><span class="line">    shape: &#123;</span><br><span class="line">        head: &#39;head&#39;,</span><br><span class="line">        arm: &#39;arm&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    say(word: string) &#123;</span><br><span class="line">        console.log(word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jack.say(&#39;hi&#39;)</span><br></pre></td></tr></table></figure><h3 id="1-10-3-接口可选属性"><a href="#1-10-3-接口可选属性" class="headerlink" title="1.10.3 接口可选属性"></a>1.10.3 接口可选属性</h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">interface Person &#123;</span><br><span class="line">    gender: string,</span><br><span class="line">    age?: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jack: Person &#x3D; &#123;</span><br><span class="line">    gender: &#39;Male&#39;</span><br><span class="line">    &#x2F;&#x2F; 可以不赋值 age 属性，因为是可选的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-4-接口只读属性"><a href="#1-10-4-接口只读属性" class="headerlink" title="1.10.4 接口只读属性"></a>1.10.4 接口只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly name: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jack: Person &#x3D; &#123;</span><br><span class="line">    name: &#39;Jack&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jack.name &#x3D; &#39;Ivan&#39; &#x2F;&#x2F; 报错: name 是只读的</span><br><span class="line">readonly&#96; vs &#96;const</span><br></pre></td></tr></table></figure><ul><li>常量使用 const</li><li>对象属性使用 readonly</li></ul><h3 id="1-10-5-函数接口"><a href="#1-10-5-函数接口" class="headerlink" title="1.10.5 函数接口"></a>1.10.5 函数接口</h3><p>因为函数也是对象，所以我们也可以通过接口来对函数做“规定”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Javascript</span><br><span class="line">interface Fn &#123;</span><br><span class="line">    (a: number, b: number): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let add: Fn &#x3D; function(a: number, b: number): number &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(1, 2))</span><br></pre></td></tr></table></figure><h3 id="1-10-6-接口继承"><a href="#1-10-6-接口继承" class="headerlink" title="1.10.6 接口继承"></a>1.10.6 接口继承</h3><p>就像 ES6 的 class 一样，接口也可以做继承操作，效果就是会继承父接口的“规定”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Javascript</span><br><span class="line">interface Animal &#123;</span><br><span class="line">    move(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Human extends Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jack: Human &#x3D; &#123;</span><br><span class="line">    age: 18,</span><br><span class="line">    name: &#39;Jack&#39;,</span><br><span class="line">    move() &#123;</span><br><span class="line">        console.log(&#39;move&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-11-命名空间"><a href="#1-11-命名空间" class="headerlink" title="1.11 命名空间"></a>1.11 命名空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;命名空间就是内部模块，目的就是解决重名问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;a.ts  声明命名空间</span><br><span class="line">&#x2F;&#x2F;TypeScript 的命名空间只对外暴露需要在外部访问的对象，命名空间内的对象通过 export 关键字对外暴露</span><br><span class="line">namespace Utils &#123;</span><br><span class="line">  export interface IPerson &#123;</span><br><span class="line">      name: string;</span><br><span class="line">      age: number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;my.ts  使用命名空间</span><br><span class="line">&#x2F;&#x2F; reference 引用命名空间(可以加也可以不加)</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;a.ts&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">const me: Utils.IPerson &#x3D; &#123;</span><br><span class="line">  name: &#39;funlee&#39;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(me); &#x2F;&#x2F; &#123;name: &#39;funlee&#39;, age: 18&#125;</span><br></pre></td></tr></table></figure><h2 id="1-12-模块"><a href="#1-12-模块" class="headerlink" title="1.12 模块"></a>1.12 模块</h2><p>模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。</p><p>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的(其实就是ES6的模块化语法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;导出模块</span><br><span class="line">export var num &#x3D; 123;</span><br><span class="line">export var str &#x3D; &quot;你好&quot;;</span><br><span class="line">export function say()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">var title &#x3D; &quot;标题&quot;;</span><br><span class="line">export default title;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引入模块</span><br><span class="line">import title,&#123;num,str,say&#125; from &#39;.&#x2F;a&#39;</span><br><span class="line">console.log(title,str,say)</span><br></pre></td></tr></table></figure><h2 id="1-13-声明文件"><a href="#1-13-声明文件" class="headerlink" title="1.13 声明文件"></a>1.13 声明文件</h2><blockquote><p>d.ts为声明文件 主要用作类型的声明</p></blockquote><ul><li>在d.ts使用了declare，表示全局声明类型，需要结合tsconfig.json一起使用才能<br>有效果。 (使用方式：类似于命名空间)</li><li>或者使用export的方式，在普通ts中将d.ts导入(使用方式：类似于模块)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;data.d.ts    注意：只有声明没有实现</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个类型</span><br><span class="line">declare type StringFunc &#x3D; () &#x3D;&gt; string;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个命名空间</span><br><span class="line">declare namespace API &#123;</span><br><span class="line">  &#x2F;&#x2F;导出CurrentUser接口类型</span><br><span class="line">  export interface CurrentUser &#123;</span><br><span class="line">    avatar?: string;</span><br><span class="line">    name?: string;</span><br><span class="line">    title?: string;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-14-作业"><a href="#1-14-作业" class="headerlink" title="1.14 作业"></a>1.14 作业</h2><p>写出下列ts代码的含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Typescript</span><br><span class="line">&#x2F;&#x2F;导出一个函数 函数名字是defineConfig，函数参数是config，参数类型是IConfigFromPlugins或者IConfig，返回值是IConfigFromPlugins或者IConfig</span><br><span class="line">export declare function defineConfig(config: IConfigFromPlugins | IConfig): IConfigFromPlugins | IConfig;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个类型叫OverlayFunc，该类型是一个函数，该函数的返回值是ReactNode</span><br><span class="line">declare type OverlayFunc &#x3D; () &#x3D;&gt; React.ReactNode;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;导出一个类型，该类型叫SiderTheme，他的值是light或者dark</span><br><span class="line">export type SiderTheme &#x3D; &#39;light&#39; | &#39;dark&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个常量，名字叫columns，他的类型是ProColumns的数组，数组中的元素是TableListItem</span><br><span class="line">const columns: ProColumns&lt;TableListItem&gt;[] &#x3D; []</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个常量，名字叫LoginMessage，他的类型是React.FC，React.FC中接收&#123;content: string&#125;类型的数据。LoginMessage的值是一个箭头函数，该函数通过解构赋值或者content作为函数的入参，函数没有返回值</span><br><span class="line">const LoginMessage: React.FC&lt;&#123;</span><br><span class="line">  content: string;</span><br><span class="line">&#125;&gt; &#x3D; (&#123; content &#125;) &#x3D;&gt; ()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;type的 | 和 &amp;</span><br><span class="line">type Env1 &#x3D; &#39;prod&#39; | &#39;test&#39; | &#39;dev&#39;;</span><br><span class="line">type Env2 &#x3D; &#39;prod&#39; | &#39;boe&#39; | &#39;ppe&#39;;</span><br><span class="line"></span><br><span class="line">type EnvUnion &#x3D; Env1 | Env2; &#x2F;&#x2F; &#39;prod&#39; | &#39;test&#39; | &#39;dev&#39; | &#39;boe&#39; | &#39;ppe&#39;  取并集</span><br><span class="line">type EnvInter &#x3D; Env1 &amp; Env2; &#x2F;&#x2F; &#39;prod&#39;   取交集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个类型叫Partial，主要作用就是将T中的每一个键可选</span><br><span class="line">type Partial&lt;T&gt; &#x3D; &#123;</span><br><span class="line">  [P in keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个类型叫Pick 主要作用选择T中的符合条件的属性</span><br><span class="line">&#x2F;&#x2F;https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_34376986&#x2F;article&#x2F;details&#x2F;93167453</span><br><span class="line">type Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;</span><br><span class="line">    [P in K]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line">                 </span><br><span class="line">&#x2F;&#x2F;判断T是不是继承U，如果是则取never类型，否则取T类型本身</span><br><span class="line">type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断T是不是继承U，如果是则取T类型，否则取never类型</span><br><span class="line">type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;</span><br><span class="line">          </span><br><span class="line">&#x2F;&#x2F;Omit 主要作用 选择T中除了K之外的其他属性          </span><br><span class="line">type Omit&lt;T, K extends keyof any&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个常量REACT_APP_ENV，他的值是test  dev  pre 或者false中的任意一个</span><br><span class="line">declare const REACT_APP_ENV: &#39;test&#39; | &#39;dev&#39; | &#39;pre&#39; | false;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h1&gt;&lt;h2 id=&quot;1-1-TS简介&quot;&gt;&lt;a href=&quot;#1-1-TS简介&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js三大家族</title>
    <link href="http://example.com/2021/04/01/JS%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8F/"/>
    <id>http://example.com/2021/04/01/JS%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8F/</id>
    <published>2021-04-01T02:36:26.000Z</published>
    <updated>2021-03-12T07:03:57.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-三大家族和一个事件对象"><a href="#1-1-三大家族和一个事件对象" class="headerlink" title="1.1 三大家族和一个事件对象"></a>1.1 三大家族和一个事件对象</h1><p>三大家族（offset/scroll/client）</p><p>事件对象/event （事件被触动时，鼠标和键盘的状态）（通过属性控制）</p><h1 id="1-2-Offset家族简介"><a href="#1-2-Offset家族简介" class="headerlink" title="1.2 Offset家族简介"></a>1.2 Offset家族简介</h1><p>offset这个单词本身是–偏移，补偿，位移的意思。</p><p>js中有一套方便的获取元素尺寸的办法就是offset家族；</p><p>offsetWidth和offsetHight以及offsetLeft和offsetTop以及offsetParent</p><p>共同组成了offset家族。</p><h3 id="1-2-1-offsetWidth和offsetHight-（检测盒子自身宽高-padding-border）"><a href="#1-2-1-offsetWidth和offsetHight-（检测盒子自身宽高-padding-border）" class="headerlink" title="1.2.1 offsetWidth和offsetHight （检测盒子自身宽高+padding+border）"></a>1.2.1 offsetWidth和offsetHight （检测盒子自身宽高+padding+border）</h3><p>这两个属性，他们绑定在了所有的节点元素上。获取之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。</p><p>offset宽/高 = 盒子自身的宽/高 + padding+border；</p><p>offsetWidth =width+padding+border；</p><p>offsetHeight =Height+padding+border；</p><h3 id="1-2-2-offsetLeft和offsetTop-（检测距离父盒子有定位的左-上面的距离）"><a href="#1-2-2-offsetLeft和offsetTop-（检测距离父盒子有定位的左-上面的距离）" class="headerlink" title="1.2.2 offsetLeft和offsetTop （检测距离父盒子有定位的左/上面的距离）"></a>1.2.2 offsetLeft和offsetTop （检测距离父盒子有定位的左/上面的距离）</h3><p>返回距离上级盒子（带有定位）左边s的位置</p><p>如果父级都没有定位则以body为准</p><p>offsetLeft 从父亲的padding 开始算,父亲的border 不算。</p><p>在父盒子有定位的情况下，offsetLeft == style.left(去掉px)</p><h3 id="1-2-3-offsetParent-（检测父系盒子中带有定位的父盒子节点）"><a href="#1-2-3-offsetParent-（检测父系盒子中带有定位的父盒子节点）" class="headerlink" title="1.2.3 offsetParent （检测父系盒子中带有定位的父盒子节点）"></a>1.2.3 offsetParent （检测父系盒子中带有定位的父盒子节点）</h3><p>1、返回改对象的父级 （带有定位）</p><p> 如果当前元素的父级元素没有进行CSS定位 （position为absolute或 relative，fixed）， offsetParent为body。</p><p>2、如果当前元素的父级元素中有CSS定位 （position为absolute或 relative，fixed）， offsetParent取最近的那个父级元素。</p><h1 id="1-3-offsetLeft和style-left区别"><a href="#1-3-offsetLeft和style-left区别" class="headerlink" title="1.3 offsetLeft和style.left区别"></a>1.3 offsetLeft和style.left区别</h1><p>一、最大区别在于offsetLeft可以返回没有定位盒子的距离左侧的位置。</p><p>而 style.left不可以</p><p>二、offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。</p><p>三、offsetTop 只读，而 style.top 可读写。（只读是获取值，可写是赋值）</p><p>四、如果没有给 HTML 元素指定过 top 样式，则style.top 返回的是空字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">style.left在&#x3D;的左边和右边还不一样。（左边的时候是属性，右边的时候是值）</span><br></pre></td></tr></table></figure><h1 id="Scroll家族组成"><a href="#Scroll家族组成" class="headerlink" title="Scroll家族组成"></a>Scroll家族组成</h1><p>ScrollWidth和scrollHeight（不包括border）</p><p>检测盒子的宽高。（调用者：节点元素。属性。）</p><p>盒子内容的宽高。（如果有内容超出了，显示内容的高度）</p><p>IE567可以比盒子小。 IE8+火狐谷歌不能比盒子小</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="scrollLeft和scrollTop"><a href="#scrollLeft和scrollTop" class="headerlink" title="scrollLeft和scrollTop"></a>scrollLeft和scrollTop</h2><p>网页，被浏览器遮挡的头部和左边部分。</p><p>被卷去的头部和左边部分。</p><p>兼容性问题</p><p>一、未声明 DTD（谷歌只认识他）</p><p>document.body.scrollTop</p><p>二、已经声明DTD（IE678只认识他）</p><p>document.documentElement.scrollTop</p><p>三、火狐/谷歌/ie9+以上支持的</p><p>window.pageYOffset</p><h2 id="兼容写法"><a href="#兼容写法" class="headerlink" title="兼容写法"></a>兼容写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">var aaa &#x3D; window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;</span><br><span class="line">Code</span><br><span class="line">var aaa &#x3D; document.documentElement.scrollTop + document.body.scrollTop;</span><br></pre></td></tr></table></figure><p>事件event</p><h2 id="1-1-事件对象的获取（event的获取）"><a href="#1-1-事件对象的获取（event的获取）" class="headerlink" title="1.1 事件对象的获取（event的获取）"></a>1.1 事件对象的获取（event的获取）</h2><p>IE678中，window.event</p><p>在火狐谷歌中，event或者，在事件绑定的函数中，加参，这个参数就是event.</p><p>Box.onclick = function (aaa){ aaa就是event }</p><h2 id="1-2-兼容获取方式有两种："><a href="#1-2-兼容获取方式有两种：" class="headerlink" title="1.2 兼容获取方式有两种："></a>1.2 兼容获取方式有两种：</h2><p>不写参数直接使用event;</p><p>写参数，但是为event….var event = event || window.event;(主要用这种)</p><h2 id="1-3-event内容重要内容"><a href="#1-3-event内容重要内容" class="headerlink" title="1.3 event内容重要内容"></a>1.3 event内容重要内容</h2><p><a href="https://img-blog.csdn.net/20170330141538969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1ppb3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"><img src="https://img-blog.csdn.net/20170330141538969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1ppb3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></a></p><p>PageY/pageX: 鼠标位于整个网页页面的顶部和左侧部分的距离。（页面）</p><p>ScreenY/screenX: 鼠标位于屏幕的上方和左侧的距离。（屏幕）</p><p>ClientX/clientY: 鼠标位于浏览器的左侧和顶部的距离。（浏览器大小和位置）</p><h2 id="1-1-PageY和pageX的兼容写法（很重要）"><a href="#1-1-PageY和pageX的兼容写法（很重要）" class="headerlink" title="1.1 PageY和pageX的兼容写法（很重要）"></a>1.1 PageY和pageX的兼容写法（很重要）</h2><p>在页面位置就等于 = 看得见的+看不见的</p><p>pageY/pageX=event.clientY/clientX+scroll().top/scroll().left</p><h1 id="client家族"><a href="#client家族" class="headerlink" title="client家族"></a>client家族</h1><h2 id="1-1-主要成员"><a href="#1-1-主要成员" class="headerlink" title="1.1 主要成员"></a>1.1 主要成员</h2><p>1、clientWidth 获取网页可视区域宽度（两种用法）</p><p>clientHeight 获取网页可视区域高度（两种用法）</p><p>调用者不同，意义不同：</p><p> 盒子调用： 指盒子本身。</p><p> body/html调用： 可视区域大小。</p><p>2、clientX 鼠标距离可视区域左侧距离（event调用）</p><p>clientY 鼠标距离可视区域上侧距离（event调用）</p><p>3、clientTop/clientLeft 盒子的border宽高</p><h2 id="1-2-三大家族区别（三大家族总结）"><a href="#1-2-三大家族区别（三大家族总结）" class="headerlink" title="1.2 三大家族区别（三大家族总结）"></a>1.2 三大家族区别（三大家族总结）</h2><h3 id="1-2-1-Width和height"><a href="#1-2-1-Width和height" class="headerlink" title="1.2.1 Width和height"></a>1.2.1 Width和height</h3><p>clientWidth = width + padding</p><p>clientHeight = height + padding</p><p>offsetWidth = width + padding + border</p><p>offsetHeight = height + padding + border</p><p>scrollWidth = 内容宽度（不包含border）width + padding</p><p>scrollHeight = 内容高度（不包含border）</p><h3 id="1-2-2-top和left"><a href="#1-2-2-top和left" class="headerlink" title="1.2.2 top和left"></a>1.2.2 top和left</h3><p>offsetTop/offsetLeft：</p><p> 调用者：任意元素。(盒子为主)</p><p> 作用：距离父系盒子中带有定位的距离。</p><p>scrollTop/scrollLeft:(盒子也可以调用，必须有滚动条)</p><p> 调用者：document.body.scrollTop/…..(window)</p><p> 作用：浏览器无法显示的部分（被卷去的部分）。</p><p>clientY/clientX:（clientTop/clientLeft 值的是border）</p><p> 调用者：event.clientX(event)</p><p> 作用：鼠标距离浏览器可视区域的距离（左、上）。</p><p>// width和height<br>// offset带border<br>// scroll不带border，内容的宽高<br>// client不带border</p><p>// top和left<br>// offset距离父系盒子带有定位的盒子之间的距离<br>// scroll被卷去的部分的距离<br>// clientborder的宽高</p><p>//clientX和clientY<br>// event调用，鼠标距离浏览器的可视区域的距离</p><h2 id="1-3-client家族特殊用法之-检浏览器宽-高度-可视区域"><a href="#1-3-client家族特殊用法之-检浏览器宽-高度-可视区域" class="headerlink" title="1.3 client家族特殊用法之:检浏览器宽/高度(可视区域)"></a>1.3 client家族特殊用法之:检浏览器宽/高度(可视区域)</h2><p><a href="https://img-blog.csdn.net/20170331094037076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1ppb3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"><img src="https://img-blog.csdn.net/20170331094037076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1ppb3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></a></p><h2 id="1-4-Onresize事件"><a href="#1-4-Onresize事件" class="headerlink" title="1.4 Onresize事件"></a>1.4 Onresize事件</h2><p>只要浏览器的大小改变，哪怕1像素，都会触动这个事件。</p><h2 id="1-5-案例：根据浏览器可视区域大小，给定背景色"><a href="#1-5-案例：根据浏览器可视区域大小，给定背景色" class="headerlink" title="1.5 案例：根据浏览器可视区域大小，给定背景色"></a>1.5 案例：根据浏览器可视区域大小，给定背景色</h2><h2 id="1-6-事件总结"><a href="#1-6-事件总结" class="headerlink" title="1.6 事件总结"></a>1.6 事件总结</h2><p>区分：</p><p>1.window.onscroll 屏幕滑动</p><p>2.window.onresize 浏览器大小变化</p><p>3.window.onload 页面加载完毕</p><p>4.div.onmousemove 鼠标在盒子上移动</p><p> （注意：不是盒子移动！！！）</p><p>5.onmouseup/onmousedown == onclick</p><h2 id="1-7-获得屏幕宽高"><a href="#1-7-获得屏幕宽高" class="headerlink" title="1.7 获得屏幕宽高"></a>1.7 获得屏幕宽高</h2><p>window.screen.width</p><p>分辨率是屏幕图像的精密度，指显示器所能显示的像素有多少。</p><p>我们的电脑一般：</p><p>横向1280个像素点，</p><p>纵向960个像素点。</p><p>我们看电影的时候是满屏和半屏的，就是这。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-1-三大家族和一个事件对象&quot;&gt;&lt;a href=&quot;#1-1-三大家族和一个事件对象&quot; class=&quot;headerlink&quot; title=&quot;1.1 三大家族和一个事件对象&quot;&gt;&lt;/a&gt;1.1 三大家族和一个事件对象&lt;/h1&gt;&lt;p&gt;三大家族（offset/scroll</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工具函数</title>
    <link href="http://example.com/2021/03/11/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/03/11/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-11T14:10:18.000Z</published>
    <updated>2021-03-12T06:50:44.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、数组去重"><a href="#1、数组去重" class="headerlink" title="1、数组去重"></a>1、数组去重</h2><p>原理：利用Js中对象的属性名不可重复的特点对数组进行去重操作</p><p>若有数组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr &#x3D; [&#39;a&#39;,&#39;v&#39;,&#39;a&#39;,&#39;b&#39;,&#39;e&#39;,&#39;b&#39;,&#39;w&#39;,&#39;x&#39;]</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var object &#x3D; &#123;&#125;;</span><br><span class="line">    for(var key in arr)</span><br><span class="line">        if(!object[arr[key]])</span><br><span class="line">            object[arr[key]] &#x3D; 1;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line">    a: 1</span><br><span class="line">    b: 1</span><br><span class="line">    e: 1</span><br><span class="line">    v: 1</span><br><span class="line">    w: 1</span><br><span class="line">    x: 1</span><br></pre></td></tr></table></figure><p>此时object对象中的属性名便是去重后的结果。</p><h2 id="2、在字符串中找到所有的字符-o，并返回其下标"><a href="#2、在字符串中找到所有的字符-o，并返回其下标" class="headerlink" title="2、在字符串中找到所有的字符 o，并返回其下标"></a>2、在字符串中找到所有的字符 o，并返回其下标</h2><p>若有字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &#39;oresdfrgosdfsdo&#39;</span><br><span class="line"> &lt;script&gt;  </span><br><span class="line">    var index &#x3D; -1;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        index &#x3D; s.indexOf(&quot;o&quot;,index+1)</span><br><span class="line">        if(index &#x3D;&#x3D; -1)</span><br><span class="line">            break;</span><br><span class="line">            console.log(index);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">8</span><br><span class="line">14</span><br></pre></td></tr></table></figure><h2 id="3、返回给定参数的数据类型"><a href="#3、返回给定参数的数据类型" class="headerlink" title="3、返回给定参数的数据类型"></a>3、返回给定参数的数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*    getType</span><br><span class="line">*    @description 返回给定参数的数据类型</span><br><span class="line">*    @param &#123;Any&#125; 需要做类型检测的参数</span><br><span class="line">*    @return &#123;String&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">function getType(args)&#123;</span><br><span class="line">    if (typeof arg &#x3D;&#x3D;&#x3D; &#39;number&#39; &amp;&amp; isNaN(arg)) return &#39;NaN&#39;;</span><br><span class="line">    let reg &#x3D; &#x2F;\s(\w&#123;1,&#125;)\]$&#x2F;g;</span><br><span class="line">    let str &#x3D; Object.prototype.toString.call(args);</span><br><span class="line">    let type &#x3D; reg.exec(str)[1];</span><br><span class="line">    return type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var b &#x3D; false;</span><br><span class="line">var c &#x3D; &#39;ss&#39;;</span><br><span class="line">var d;</span><br><span class="line">var e &#x3D; null;</span><br><span class="line">var f &#x3D; NaN;</span><br><span class="line">var g &#x3D; &#123;&#125;;</span><br><span class="line">var h &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">var i &#x3D; [];</span><br><span class="line">console.log(checkType(a));</span><br><span class="line">console.log(checkType(b));</span><br><span class="line">console.log(checkType(c));</span><br><span class="line">console.log(checkType(d));</span><br><span class="line">console.log(checkType(e));</span><br><span class="line">console.log(checkType(f));</span><br><span class="line">console.log(checkType(g));</span><br><span class="line">console.log(checkType(h));</span><br><span class="line">console.log(checkType(i));</span><br></pre></td></tr></table></figure><h2 id="4、什么时候-val-1-amp-amp-val-2-amp-amp-val-3-为-true？"><a href="#4、什么时候-val-1-amp-amp-val-2-amp-amp-val-3-为-true？" class="headerlink" title="4、什么时候 val === 1 &amp;&amp; val === 2 &amp;&amp; val === 3 为 true？"></a>4、什么时候 val === 1 &amp;&amp; val === 2 &amp;&amp; val === 3 为 true？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var i&#x3D; 0;</span><br><span class="line">Object.defineProperty(window,&#39;val&#39;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return ++i;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function()&#123;</span><br><span class="line">        console.log(&#39;set&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(val &#x3D;&#x3D;&#x3D; 1 &amp;&amp; val &#x3D;&#x3D;&#x3D; 2 &amp;&amp; val &#x3D;&#x3D;&#x3D; 3);</span><br></pre></td></tr></table></figure><h2 id="5、计算一段文本的宽度"><a href="#5、计算一段文本的宽度" class="headerlink" title="5、计算一段文本的宽度"></a>5、计算一段文本的宽度</h2><p><strong>React</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @name: text-width ;</span><br><span class="line"> * @author: admin ;</span><br><span class="line"> * @description: 获取字符串宽度 ;</span><br><span class="line"> * *&#x2F;</span><br><span class="line">import memoize from &#39;lodash&#x2F;memoize&#39;;</span><br><span class="line">export default memoize((text, fontSize, options) &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;fontFamily, fontWeight&#125; &#x3D; Object.assign(&#123;fontFamily: &#39;Arial&#39;, fontWeight: &#39;normal&#39;&#125;, options);</span><br><span class="line">    const canvas &#x3D; document.createElement(&#39;canvas&#39;),</span><br><span class="line">          ctx &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">    ctx.font &#x3D; &#96;$&#123;fontSize&#125; $&#123;fontFamily&#125; $&#123;fontWeight&#125;&#96;;</span><br><span class="line">    return ctx.measureText(text).width;</span><br><span class="line">&#125;, (text, fontSize, options) &#x3D;&gt; &#123;</span><br><span class="line">    const obj &#x3D; Object.assign(&#123;&#125;, options, &#123;text, fontSize&#125;);</span><br><span class="line">    return Object.keys(obj).map((key) &#x3D;&gt; &#96;$&#123;key&#125;-$&#123;obj[key]&#125;&#96;).join(&#39;,&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、数组去重&quot;&gt;&lt;a href=&quot;#1、数组去重&quot; class=&quot;headerlink&quot; title=&quot;1、数组去重&quot;&gt;&lt;/a&gt;1、数组去重&lt;/h2&gt;&lt;p&gt;原理：利用Js中对象的属性名不可重复的特点对数组进行去重操作&lt;/p&gt;
&lt;p&gt;若有数组:&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算属性computed</title>
    <link href="http://example.com/2021/03/11/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed/"/>
    <id>http://example.com/2021/03/11/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed/</id>
    <published>2021-03-11T14:00:19.000Z</published>
    <updated>2021-03-12T07:10:30.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h3 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h3><p>我们知道，在模板中可以直接通过插值语法显示一些data中的数据</p><p>但是在某些情况下，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如我们有&#96;firstName&#96;和&#96;lastName&#96;两个变量，我们需要显示完整的名称</span><br><span class="line">但是如果多个地方都需要显示完整的名称，我们就需要写多个&#96;&#123;&#123;firstName&#125;&#125;&#96;和&#96;&#123;&#123;lastName&#125;&#125;&#96;</span><br></pre></td></tr></table></figure><p>我们可以将上面的代码换成计算属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们发现计算属性是写在实例的&#96;computed&#96;选项中的</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName+&#x27;  &#x27;+lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">`#app`</span>,</span></span><br><span class="line">            data: &#123; </span><br><span class="line"><span class="javascript">                firstName: <span class="string">&#x27;Lebron&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                lastName:<span class="string">&#x27;James&#x27;</span> </span></span><br><span class="line">            &#125;,</span><br><span class="line">            computed:&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">/* 计算属性，一般不用动词 */</span></span></span><br><span class="line"><span class="javascript">                fullName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;  &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                getFullName ()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;  &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>计算属性不要加小括号()</p><h3 id="计算属性的复杂操作"><a href="#计算属性的复杂操作" class="headerlink" title="计算属性的复杂操作"></a>计算属性的复杂操作</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格:&#123;&#123;totalPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">`#app`</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line">                books: [</span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&#x27;Unix编程艺术&#x27;</span>, <span class="attr">price</span>: <span class="number">119</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&#x27;代码大全&#x27;</span>, <span class="attr">price</span>: <span class="number">105</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">id</span>: <span class="number">112</span>, <span class="attr">name</span>: <span class="string">&#x27;深入理解计算机原理&#x27;</span>, <span class="attr">price</span>: <span class="number">98</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">id</span>: <span class="number">113</span>, <span class="attr">name</span>: <span class="string">&#x27;现代操作系统&#x27;</span>, <span class="attr">price</span>: <span class="number">87</span> &#125;,</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line"><span class="javascript">                totalPrice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> result  =<span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.books.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        result += <span class="built_in">this</span>.books[i].price</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> result</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="计算属性的setter和getter"><a href="#计算属性的setter和getter" class="headerlink" title="计算属性的setter和getter"></a>计算属性的<code>setter</code>和<code>getter</code></h3><p>我们之前在计算属性的基础操作中使用了一个方法<code>fullName</code>,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fullName:function()&#123;</span><br><span class="line">                    return this.firstName + &#39;  &#39; + this.lastName</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>其实是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">                fullName:&#123;</span><br><span class="line">                    set:function()&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;,</span><br><span class="line">                    get:function()&#123;</span><br><span class="line">                        return this.firstName + &#39;  &#39; + this.lastName</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>其中<code>set</code>属性是不需要实现的，我们不希望计算属性有<code>set</code>属性，其实计算属性是个只读属性，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">                fullName:&#123;</span><br><span class="line">                    get:function()&#123;</span><br><span class="line">                        return this.firstName + &#39;  &#39; + this.lastName</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>我们方便使用就使用第一种方式</p><p><strong>计算属性的方法，即使调用多次，计算属性也只是调用了一次，内部是有缓存的</strong>，如果方法的返回结果不变，就不会重复调用多次，直接调用缓存。</p><p><strong>使用<code>methods</code>的时候，调用几次，函数就会调用几次</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; title=&quot;计算属性&quot;&gt;&lt;/a&gt;计算属性&lt;/h1&gt;&lt;h3 id=&quot;什么是计算属性&quot;&gt;&lt;a href=&quot;#什么是计算属性&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2021/03/11/MySQL/"/>
    <id>http://example.com/2021/03/11/MySQL/</id>
    <published>2021-03-11T12:39:46.000Z</published>
    <updated>2021-03-12T07:04:47.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1、确保已安装wamp并且启动成功"><a href="#1、确保已安装wamp并且启动成功" class="headerlink" title="1、确保已安装wamp并且启动成功"></a>1、确保已安装wamp并且启动成功</h2><p>详情请见<a href="https://howlcn.github.io/2019/05/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">wamp环境搭建</a></p><h2 id="2、下载navicat-premium"><a href="#2、下载navicat-premium" class="headerlink" title="2、下载navicat premium"></a>2、下载navicat premium</h2><p>文件 -&gt; 新建连接</p><p>点击自己新建的链接，新建数据库 字符集uft8 排序规则utf8_bin</p><h2 id="3、在项目文件夹中安装mySQL"><a href="#3、在项目文件夹中安装mySQL" class="headerlink" title="3、在项目文件夹中安装mySQL"></a>3、在项目文件夹中安装mySQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install mysqljs&#x2F;mysql</span><br></pre></td></tr></table></figure><h2 id="4、在服务器js文件中使用mysql包"><a href="#4、在服务器js文件中使用mysql包" class="headerlink" title="4、在服务器js文件中使用mysql包"></a>4、在服务器js文件中使用mysql包</h2><h3 id="引入mysql包"><a href="#引入mysql包" class="headerlink" title="引入mysql包"></a>引入mysql包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mysql &#x3D; require(&#39;mysql&#39;);</span><br></pre></td></tr></table></figure><h3 id="创建数据库链接"><a href="#创建数据库链接" class="headerlink" title="创建数据库链接"></a>创建数据库链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const connection &#x3D; mysql.createConnection(&#123;</span><br><span class="line">host: &#39;localhost&#39;, &#x2F;&#x2F;数据库所在的服务器的域名（或ip地址）</span><br><span class="line">user: &#39;me&#39;, &#x2F;&#x2F;登录数据库的账号</span><br><span class="line">password: &#39;secret&#39;, &#x2F;&#x2F;登陆数据库的密码</span><br><span class="line">database: &#39;book&#39; &#x2F;&#x2F;数据库的名称</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="执行链接操作"><a href="#执行链接操作" class="headerlink" title="执行链接操作"></a>执行链接操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.connect();</span><br></pre></td></tr></table></figure><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>数据库的操作是异步的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&#39;数据库操作语句&#39;,function(error,results,fields)&#123; &#x2F;&#x2F;results 数据库语句执行完后的结果</span><br><span class="line">if(error) throw error;</span><br><span class="line">console.log(&#39;The solution is:&#39;,results[0].solution);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.end();</span><br></pre></td></tr></table></figure><h2 id="数据库常用语句"><a href="#数据库常用语句" class="headerlink" title="数据库常用语句"></a>数据库常用语句</h2><p>先给出代码大概框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const mysql &#x3D; require(&#39;mysql&#39;);</span><br><span class="line"></span><br><span class="line">const connection &#x3D; mysql.createConnection(&#123;</span><br><span class="line">    host: &#39;localhost&#39;, &#x2F;&#x2F;数据库所在的服务器的域名（或ip地址）</span><br><span class="line">    user: &#39;root&#39;, &#x2F;&#x2F;登录数据库的账号</span><br><span class="line">    password: &#39;&#39;, &#x2F;&#x2F;登陆数据库的密码</span><br><span class="line">    database: &#39;book&#39; &#x2F;&#x2F;数据库的名称</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此处开始进行数据库数据操作**********************之后的代码只有此处不同</span><br><span class="line">&#x2F;&#x2F; ？ 是为了给后面的数据进行填充</span><br><span class="line">let sql &#x3D; &#39;insert into book set ?&#39;;</span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &#39;百年孤独&#39;,</span><br><span class="line">    author: &#39;加西亚·马尔克斯&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">connection.query(sql,data,function(error,results,fields)&#123; &#x2F;&#x2F;results 数据库语句执行完后的结果 是个对象</span><br><span class="line">    if(error) throw error;</span><br><span class="line">    if(results.affectedRows &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        console.log(&#39;数据插入成功！&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此处结束数据库数据操作************************</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ？ 是为了给后面的数据进行填充</span><br><span class="line">let sql &#x3D; &#39;insert into book set ?&#39;;</span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &#39;百年孤独&#39;,</span><br><span class="line">    author: &#39;加西亚·马尔克斯&#39;</span><br><span class="line">&#125;;</span><br><span class="line">connection.query(sql,data,function(error,results,fields)&#123; &#x2F;&#x2F;results 数据库语句执行完后的结果</span><br><span class="line">    if(error) throw error;</span><br><span class="line">    if(results.affectedRows &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        console.log(&#39;数据插入成功！&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let sql &#x3D; &#39;delete from book where id&#x3D;?&#39;;</span><br><span class="line">let data &#x3D; [2];</span><br><span class="line"></span><br><span class="line">connection.query(sql,data,function(error,results,fields)&#123; &#x2F;&#x2F;results 数据库语句执行完后的结果</span><br><span class="line">    if(error) throw error;</span><br><span class="line">    if(results.affectedRows &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        console.log(&#39;数据删除成功！&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let sql &#x3D; &#39;update book set name&#x3D;?,author&#x3D;? where id&#x3D;?&#39;;</span><br><span class="line">let data &#x3D; [&#39;红楼梦&#39;,&#39;曹雪芹&#39;,2];</span><br><span class="line"></span><br><span class="line">connection.query(sql,data,function(error,results,fields)&#123; &#x2F;&#x2F;results 数据库语句执行完后的结果</span><br><span class="line">    if(error) throw error;</span><br><span class="line">    if(results.affectedRows &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        console.log(&#39;数据更新成功！&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;let sql &#x3D; &#39;select * from book&#39;; &#x2F;&#x2F; * 查询范围是全部数据</span><br><span class="line">&#x2F;&#x2F;let data &#x3D; null;</span><br><span class="line"></span><br><span class="line">let sql &#x3D; &#39;select * from book where id &#x3D; ?&#39;;  &#x2F;&#x2F;从所有数据中查询id为？的数据</span><br><span class="line">let data &#x3D; [1];</span><br><span class="line"></span><br><span class="line">connection.query(sql,data,function(error,results,fields)&#123; &#x2F;&#x2F;results 数据库语句执行完后的结果</span><br><span class="line">if(error) throw error;</span><br><span class="line">    console.log(results[0].name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难发现对数据的增删改查在代码层面是类似的。</p><h3 id="封装对数据库的操作"><a href="#封装对数据库的操作" class="headerlink" title="封装对数据库的操作"></a>封装对数据库的操作</h3><p>新建一个db.js文件，此js中的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const mysql &#x3D; require(&#39;mysql&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当sql是插入操作时，data需要是一个对象</span><br><span class="line">&#x2F;&#x2F;当sql是删改查时，data是一个数组数组中的数据与表中的字段顺序要一一对应</span><br><span class="line">exports.base &#x3D; (sql,data,callback)&#x3D;&gt;&#123;</span><br><span class="line">    const connection &#x3D; mysql.createConnection(&#123;</span><br><span class="line">        host: &#39;localhost&#39;,</span><br><span class="line">        user: &#39;root&#39;,</span><br><span class="line">        password: &#39;&#39;,</span><br><span class="line">        database: &#39;book&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">    connection.connect();</span><br><span class="line">    connection.query(sql,data,function(error,results,fields)&#123;</span><br><span class="line">        if(error) throw error;</span><br><span class="line">        callback(results);</span><br><span class="line">    &#125;);</span><br><span class="line">    connection.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h2 id=&quot;1、确保已安装wamp并且启动成功&quot;&gt;&lt;a href=&quot;#1、确保已安装wamp并且启动成功&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nuxt</title>
    <link href="http://example.com/2021/03/11/Nuxt/"/>
    <id>http://example.com/2021/03/11/Nuxt/</id>
    <published>2021-03-11T12:32:57.000Z</published>
    <updated>2021-03-12T07:06:36.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p> Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染(SSR)的 Vue 应用提供了极其便利的开发体验。</p><p> Vue.js是开发SPA单页面应用的，传统的SPA应用是将bundle.js从服务端获取，然后在客户端解析并挂载到dom。</p><p> Nuxt这个框架是用Vue开发多页应用，并在服务端渲染。我们可以将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p> Nuxt适合做新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。如果你要做到是移动端项目，就没有必要用nuxt这个框架了。</p><p>Nuxt是基于Vue.js的服务端渲染框架，可以很好的解决SPA应用程序的首次加载问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Nuxt.js有如下特点：</span><br><span class="line">Vue 2 ： nuxt是基于Vue2开发的</span><br><span class="line">Vue Router  ： nuxt整合了路由功能，配置非常简单</span><br><span class="line">VueX  ： 支持vuex</span><br><span class="line">Vue Server Renderer  ： 支持服务端渲染</span><br><span class="line">Vue-meta  ： 支持meta标签配置</span><br></pre></td></tr></table></figure><p>Nuxt机制图示</p><p>未使用Nuxt：</p><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/noNuxt.png" alt="noNuxt"></p><p>使用Nuxt：</p><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/nuxt.png" alt="nuxt"></p><h2 id="二、创建Nuxt项目"><a href="#二、创建Nuxt项目" class="headerlink" title="二、创建Nuxt项目"></a>二、创建Nuxt项目</h2><p><a href="https://zh.nuxtjs.org/guide/installation/#%E6%96%B0%E6%89%8B%E6%A8%A1%E6%9D%BF">新手模板</a></p><p>确保安装了npx（npx在NPM版本5.2.0默认安装了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-nuxt-app &lt;项目名&gt;</span><br></pre></td></tr></table></figure><p>或者使用yarn:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn create nuxt-app &lt;项目名&gt;</span><br></pre></td></tr></table></figure><p>配置：</p><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:3000</span><br></pre></td></tr></table></figure><h2 id="三、Nuxt基本使用"><a href="#三、Nuxt基本使用" class="headerlink" title="三、Nuxt基本使用"></a>三、Nuxt基本使用</h2><h3 id="3-1-路由"><a href="#3-1-路由" class="headerlink" title="3.1 路由"></a>3.1 路由</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;pages文件夹下面，文件名即路由</span><br><span class="line"></span><br><span class="line">#1.pages下新建search.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    这是search页面</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.index.vue使用路由 此处的search就是所创建的search.vue的文件名</span><br><span class="line">&lt;nuxt-link to&#x3D;&quot;&#x2F;search&quot;&gt;到search页面&lt;&#x2F;nuxt-link&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-嵌套子模版"><a href="#3-2-嵌套子模版" class="headerlink" title="3.2 嵌套子模版"></a>3.2 嵌套子模版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#index.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">      &lt;section class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;logo&#x2F;&gt;</span><br><span class="line">             &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;section&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Logo from &#39;~&#x2F;components&#x2F;Logo.vue&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Logo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-layouts布局文件"><a href="#3-3-layouts布局文件" class="headerlink" title="3.3 layouts布局文件"></a>3.3 layouts布局文件</h3><p> 默认情况下所有的页面都会默认使用layouts下面default.vue这个布局文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#default.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;头部&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;!--nuxt就相当于 router-view--&gt;</span><br><span class="line">    &lt;nuxt&#x2F;&gt;                     </span><br><span class="line">    &lt;h1&gt;尾巴&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>当然也可以创建自定义的布局文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义布局文件</span><br><span class="line">&#x2F;&#x2F;1.layouts下新建一个user.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;用户页面头部&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;nuxt&#x2F;&gt;</span><br><span class="line">    &lt;h1&gt;用户页面底部&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;css&quot; scoped&gt;</span><br><span class="line">  h1&#123;</span><br><span class="line">    color:green</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.pages下的search.vue指定使用哪个布局文件</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">    layout:&quot;user&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-4-全局CSS文件"><a href="#3-4-全局CSS文件" class="headerlink" title="3.4 全局CSS文件"></a>3.4 全局CSS文件</h3><p> 此css 文件将在所有组件中自动生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1.在assets下新建css&#x2F;main.css</span><br><span class="line"></span><br><span class="line">#2.修改nuxt.config.css配置文件后</span><br><span class="line">&#x2F;*</span><br><span class="line">** global css</span><br><span class="line">*&#x2F;</span><br><span class="line">css: [</span><br><span class="line">    &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;,</span><br><span class="line">    &#39;~assets&#x2F;css&#x2F;main.css&#39;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">#3.重启服务(配置文件的修改，重启后才能生效)</span><br></pre></td></tr></table></figure><h3 id="3-5-Vuex的使用"><a href="#3-5-Vuex的使用" class="headerlink" title="3.5 Vuex的使用"></a>3.5 Vuex的使用</h3><p> 在nuxt中使用vuex的时候无需new Vue.Store实例，nuxt会帮我们自动创建。默认情况下，会使用index.js这个store。</p><p> 每次修改增加Vuex时要重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#1.store&#x2F;index.js</span><br><span class="line">&#x2F;&#x2F;state存放数据</span><br><span class="line">export const state &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  list: [&#39;a&#39;,&#39;b&#39;],</span><br><span class="line">  user:&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;修改state</span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">  increment (state,text) &#123;</span><br><span class="line">    state.list.push(text);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;异步提交mutations</span><br><span class="line">export const actions &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#2.store&#x2F;city.js</span><br><span class="line">export const state &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  list: [&#39;c&#39;,&#39;d&#39;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">  increment (state,text) &#123;</span><br><span class="line">    state.list.push(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vue文件中使用vuex</p><ol><li>使用store/index.js中的state时 <code>$store.state.list</code></li><li>使用store/city.js中的state时 <code>$store.state.city.list</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#3.pages&#x2F;city.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Page is city</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li</span><br><span class="line">        v-for&#x3D;&quot;(item,idx) in $store.state.list&quot;</span><br><span class="line">        :key&#x3D;&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; </span><br><span class="line">       &lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input</span><br><span class="line">        type&#x3D;&quot;button&quot;</span><br><span class="line">        value&#x3D;&quot;增加信息index&quot;</span><br><span class="line">        @click&#x3D;&quot;addIndex&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;li</span><br><span class="line">        v-for&#x3D;&quot;(item,idx) in $store.state.city.list&quot;</span><br><span class="line">        :key&#x3D;&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; </span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input</span><br><span class="line">      type&#x3D;&quot;button&quot;</span><br><span class="line">      value&#x3D;&quot;增加信息city&quot;</span><br><span class="line">      @click&#x3D;&quot;addCity&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import axios from &quot;axios&quot;</span><br><span class="line">  export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        list:[]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      addIndex()&#123;</span><br><span class="line">        this.$store.commit(&#39;increment&#39;, &quot;kk&quot;)</span><br><span class="line">      &#125;,</span><br><span class="line">      addCity()&#123;</span><br><span class="line">        this.$store.commit(&#39;city&#x2F;increment&#39;, &quot;jj&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="四、SPA-SEO-SSR"><a href="#四、SPA-SEO-SSR" class="headerlink" title="四、SPA\SEO\SSR"></a>四、SPA\SEO\SSR</h2><h3 id="4-1-SPA-单页面应用"><a href="#4-1-SPA-单页面应用" class="headerlink" title="4.1 SPA:单页面应用"></a>4.1 SPA:单页面应用</h3><blockquote><p>SPA 时代，主要是在客户端端使用了<code>history</code>或<code>hash</code>（主要是为了低版本浏览器的兼容）API，在首次请求经服务端路由输出整个应用程序后，接下来的路由都由前端掌控了，前端通过路由作为中心枢纽控制一系列页面（组件）的渲染(DOM的生成)加载和数据交互。</p></blockquote><p>优点：</p><ol><li>页面之间的切换非常快</li><li>一定程度减少了后端服务器的压力</li><li>实现前后端分离，后端程序只需要提供api，不需要客户端到底是web端还是手机等</li></ol><p>缺点：</p><ol><li>首屏打开速度很慢</li><li>不利于SEO搜索引擎优化</li></ol><h3 id="4-2-SEO-搜索引擎优化"><a href="#4-2-SEO-搜索引擎优化" class="headerlink" title="4.2 SEO:搜索引擎优化"></a>4.2 SEO:搜索引擎优化</h3><blockquote><p>SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。</p><p>由于SPA使用Ajax动态获取数据，很难保证搜索引擎的正常爬取，并且有些搜索引擎不支持js和Ajax获取的数据，因此SSR诞生</p></blockquote><h3 id="4-3-SSR-服务器端渲染"><a href="#4-3-SSR-服务器端渲染" class="headerlink" title="4.3 SSR:服务器端渲染"></a>4.3 SSR:服务器端渲染</h3><blockquote><p>为了解决SPA不支持SEO的问题，我们也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，但是这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。</p></blockquote><p>基本流程：当客户端向服务器发送请求后，web服务器根据路由拿到对应数据渲染并输出，且输出部分中包含两部分：</p><ol><li>路由页对应的页面及已渲染好的数据（解决首屏加载）</li><li>完整的SPA程序代码 （本地路由跳转，而不请求服务器）</li></ol><p>优点：</p><ol><li>更好的 SEO（搜索引擎爬虫抓取工具可以直接查看完全渲染的页面）</li><li>更快的内容到达时间 （不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了）</li></ol><p>缺点：</p><ol><li>占用更多的cpu和内存资源</li><li>一些常用的浏览器的api可能无法正常使用 （如：window，document，alert）</li><li>开发调试会有一些麻烦 （因为涉及到了浏览器及服务器，对于SPA的一些组件的声明周期的管理会变得复杂）</li></ol><h3 id="4-4-Nuxt对SSR支持"><a href="#4-4-Nuxt对SSR支持" class="headerlink" title="4.4 Nuxt对SSR支持"></a>4.4 Nuxt对SSR支持</h3><blockquote><p>从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 <a href="https://nuxtjs.org/">Nuxt.js</a> 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。</p><p>Nuxt.js 是使用 Webpack 和 Node.js 进行封装的基于Vue的SSR框架，预设了利用Vue.js开发<strong>服务端渲染</strong>的应用所需要的各种配置，使用它你可以不需要自己搭建一套 SSR 程序，而是通过其约定好的文件结构和API就可以实现一个首屏渲染的 Web 应用。</p><p>Nuxt.js 主要关注的是应用的 UI渲染。</p></blockquote><p><a href="https://juejin.im/post/58ff960ba22b9d0065b722cd">实现基于 Nuxt.js 的 SSR 应用</a></p><h2 id="五、数据预取"><a href="#五、数据预取" class="headerlink" title="五、数据预取"></a>五、数据预取</h2><h3 id="5-1-准备服务器接口"><a href="#5-1-准备服务器接口" class="headerlink" title="5.1 准备服务器接口"></a>5.1 准备服务器接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#1.server&#x2F;interface&#x2F;city.js</span><br><span class="line">var express &#x3D; require(&#39;express&#39;)</span><br><span class="line">var router &#x3D; express.Router()</span><br><span class="line">router.get(&#39;&#x2F;info&#39;, function (req, res) &#123;</span><br><span class="line">    return res.status(200).json([&#39;北京&#39;,&#39;天津&#39;])</span><br><span class="line">&#125;)</span><br><span class="line">module.exports &#x3D; router</span><br><span class="line"></span><br><span class="line">#2.server&#x2F;index.js</span><br><span class="line">const cityInterface &#x3D; require(&quot;.&#x2F;interface&#x2F;city&quot;)</span><br><span class="line">&#x2F;&#x2F;在app.use(nuxt.render)上面添加app.use(&quot;&#x2F;city&quot;,cityInterface)</span><br><span class="line">app.use(&quot;&#x2F;city&quot;,cityInterface);</span><br><span class="line">app.use(nuxt.render)</span><br><span class="line"></span><br><span class="line">#.重启服务</span><br><span class="line">localhost:3000&#x2F;city&#x2F;info  测试接口</span><br></pre></td></tr></table></figure><h3 id="5-2-不适用数据预取"><a href="#5-2-不适用数据预取" class="headerlink" title="5.2 不适用数据预取"></a>5.2 不适用数据预取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#1.客户端pages下新建city.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Page is city</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li</span><br><span class="line">        v-for&#x3D;&quot;(item,idx) in list&quot;</span><br><span class="line">        :key&#x3D;&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import axios from &quot;axios&quot;</span><br><span class="line">  export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        list:[]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;async表示方法返回一个Promise</span><br><span class="line">    &#x2F;&#x2F;await 同步等待</span><br><span class="line">    async mounted()&#123;</span><br><span class="line">      let &#123;status,data&#125; &#x3D; await axios.get(&quot;&#x2F;city&#x2F;info&quot;);</span><br><span class="line">      this.list &#x3D; data;</span><br><span class="line">      console.log(this.list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="5-3-Nuxt-js的工作流"><a href="#5-3-Nuxt-js的工作流" class="headerlink" title="5.3 Nuxt.js的工作流"></a>5.3 Nuxt.js的工作流</h3><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/1546049173524.png" alt="1546049173524"></p><ul><li>nuxtServerInit：如果在状态树(store)中指定了 <code>nuxtServerInit</code> 方法，Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（仅在服务端调用）。当我们想将服务端的一些数据传到客户端时，这个方法是非常好用的</li><li>middleware：中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前，服务端首屏渲染和路由跳转前均执行对应中间件。可以用作页面跳转时验证用户信息操作(登陆拦截)。</li><li>asyncData会在组件加载前（限于页面组件）调用，可以在<strong>服务端首屏渲染或者在路由跳转时执行</strong>，专门用来请求数据，Nuxt.js 会将 <code>asyncData</code> 返回的数据融合组件 <code>data</code> 方法返回的数据一并返回给当前组件。asyncData应该是用于影响SEO的内容，也就是需要让爬虫读取的内容。</li></ul><h3 id="5-4-服务端数据预取"><a href="#5-4-服务端数据预取" class="headerlink" title="5.4 服务端数据预取"></a>5.4 服务端数据预取</h3><h4 id="nuxtServerInit"><a href="#nuxtServerInit" class="headerlink" title="nuxtServerInit"></a>nuxtServerInit</h4><blockquote><p>nuxtServerInit可以将服务端的数据通过vuex同步到客户端，该方法仅会在服务端首屏渲染时执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#store&#x2F;index.js</span><br><span class="line">export const state &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  list: [],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">  setlist (state,text) &#123;</span><br><span class="line">    text.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">      state.list.push(item)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const actions &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;将菜单信息写入到vuex实例中</span><br><span class="line">  async nuxtServerInit (&#123; commit &#125;, &#123; req ,app &#125;) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      let &#123;status, data&#125; &#x3D; await app.$axios.get(&quot;&#x2F;city&#x2F;info&quot;);</span><br><span class="line">      commit(&#39;setlist&#39;, data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#2.pages&#x2F;city.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Page is city</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li</span><br><span class="line">        v-for&#x3D;&quot;(item,idx) in $store.state.list&quot;</span><br><span class="line">        :key&#x3D;&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h4 id="asyncData和fetch方法"><a href="#asyncData和fetch方法" class="headerlink" title="asyncData和fetch方法"></a>asyncData和fetch方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用asyncData进行ssr渲染</span><br><span class="line">async asyncData()&#123;</span><br><span class="line">    &#x2F;&#x2F;给data取别名，请求网址写全，因为在刷新浏览器的时候需要全路径请求服务器</span><br><span class="line">    let &#123;status,data:list&#125; &#x3D; await axios.get(&quot;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;city&#x2F;info&quot;);</span><br><span class="line">    if(status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">        &#x2F;&#x2F;这边不能使用this.list &#x3D; list,因为获取不到this</span><br><span class="line">        &#x2F;&#x2F;通过return给页面返回数据</span><br><span class="line">        return &#123;</span><br><span class="line">            list</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async fetch (&#123; store, params &#125;)&#123;</span><br><span class="line">      &#x2F;&#x2F;当页面加载时触发可以执行请求来触发action来修改state</span><br><span class="line">      &#x2F;&#x2F;不可以return数据给页面</span><br><span class="line">      &#x2F;&#x2F;页面可以从this.$store中获取action修改的state</span><br><span class="line">      let &#123;status,data:list&#125; &#x3D; await axios.get(&quot;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;city&#x2F;info&quot;);</span><br><span class="line">      store.commit(&#39;setlist&#39;, list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：asyncData 和 fetch都只能够在页面组件中使用，如果想要在页面组件的子组件中使用ssr，可以使用nuxtServerInit<br>#注意点：由于 asyncData方法是在组件初始化前被调用的，所以在方法内是没有办法通过this来引用组件的实例。<br>#注意点：当用户请求页面时候服务端会先使用SSR来生成对应的页面文档结构，而在用户切换路由则是使用了SPA的模式。这意味着如果用户刷新页面，asyncData方法会在服务端执行；如果用户通过nuxt-link路由导航到当前页面，asyncData会在客户端执行</p><h3 id="5-5客户端数据预取"><a href="#5-5客户端数据预取" class="headerlink" title="5.5客户端数据预取"></a>5.5客户端数据预取</h3><blockquote><p>当asyncData方法是由路由跳转触发的时候，则使用客户端数据预取，asyncData方法会在客户端执行。可以通过控制台打印来查看是在浏览器执行还是在node执行就可以验证了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async asyncData(context)&#123;</span><br><span class="line">    &#x2F;&#x2F;给data取别名，请求网址写全</span><br><span class="line">    let &#123;status,data:list&#125; &#x3D; await axios.get(&quot;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;city&#x2F;info&quot;);</span><br><span class="line">    &#x2F;&#x2F;如果是客户端执行，则可以使用window对象</span><br><span class="line">    &#x2F;&#x2F;如果是服务端执行，则没有window对象</span><br><span class="line">    if(process.client)&#123;</span><br><span class="line">        console.log(window)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">        &#x2F;&#x2F;这边不能使用this.list &#x3D; list,因为获取不到this</span><br><span class="line">        &#x2F;&#x2F;通过return给页面返回数据</span><br><span class="line">        return &#123;</span><br><span class="line">            list</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、SSR原理"><a href="#六、SSR原理" class="headerlink" title="六、SSR原理"></a>六、SSR原理</h2><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180524/92672015b4914784ae5a800c4a655e25.jpeg" alt="img"></p><p><a href="https://ssr.vuejs.org/zh/">官方文档</a></p><p>如上图所示：webpack将 Source 打包出两个bundle文件。</p><ul><li><p>服务端渲染：Server Bundle用于服务端渲染，主要是获取异步数据，同步到组件中，并将组件渲染成HTML返回到前端，但是<strong>vue-ssr不能绑定javascript事件</strong>，也就是说服务器端使用vue-ssr渲染出来的返回到浏览器的也只能是HTML+CSS。</p></li><li><p>客户端渲染：Client Bundle 用于客户端渲染，之前说过服务器不能增加事件，那只能前端增加。所以我们看到SSR渲染的网页源码中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.__NUXT__&#x3D;...</span><br></pre></td></tr></table></figure><p>代码，这是后端和前端在使用vuex共享数据。后端从vuex里面取到数据之后渲染成真正的HTML和css返回。客户端也是从vuex里面取到数据，客户端的渲染主要做2件事：</p><ul><li>拿到数据，使用 virtual-dom进行预渲染，然后和服务端渲染出来的进行比对，比对两边渲染的内容是不是一致的</li><li>对DOM元素的事件进行绑定，也就是回答的问题，事件在这块进行的处理</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nuxt&quot;&gt;&lt;a href=&quot;#Nuxt&quot; class=&quot;headerlink&quot; title=&quot;Nuxt&quot;&gt;&lt;/a&gt;Nuxt&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Less</title>
    <link href="http://example.com/2021/03/11/Less/"/>
    <id>http://example.com/2021/03/11/Less/</id>
    <published>2021-03-11T12:31:03.000Z</published>
    <updated>2021-03-12T07:04:24.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h1><p>less是动态的样式表<strong>语言</strong>，通过简明的语法定义，使编写cs’s的工作变得非常简单，本质上，less包含一套自定义的语法以及i一个解析器。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、安装Nodejs环境</p><p>2、cmd中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g less</span><br></pre></td></tr></table></figure><p>3、验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lessc -v    &#x2F;&#x2F;若正确出现less版本号则安装成功</span><br></pre></td></tr></table></figure><h2 id="使用less编译"><a href="#使用less编译" class="headerlink" title="使用less编译"></a>使用less编译</h2><p> 先创建一个less文件 demo.less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@color: #ccc;</span><br><span class="line">div &#123;</span><br><span class="line">color: @color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在当前目录下运行cmd，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lessc demo.less demo.css</span><br></pre></td></tr></table></figure><p>运行之后会在当前目录下生成一个demo.css文件，内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  color: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VsCode中使用less"><a href="#VsCode中使用less" class="headerlink" title="VsCode中使用less"></a>VsCode中使用less</h2><p> 1、添加 Easy Less 扩展插件，安装，安装完后最好重启一次VSCode；</p><p> 2、在需要生成css文件的地方，新建一个<code>.less</code>文件；</p><p> 3、保存后，会在同级目录下自动生成一个同名css文件</p><h2 id="less的基本语法"><a href="#less的基本语法" class="headerlink" title="less的基本语法"></a>less的基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*注释*&#x2F;        这种注释方式会也会编译到css中</span><br><span class="line">&#x2F;&#x2F;              这种注释方式在编译时会被去除</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p> @变量名: 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@baseColor: #eee;     &#x2F;&#x2F;申明一个变量并赋值</span><br><span class="line">a &#123;</span><br><span class="line">    color: @@baseColor;   &#x2F;&#x2F;使用变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><p> 可以将一个定义好的变量引入到另一个样式中 类似于函数的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先写好一个样式  @r 类似于函数的形参</span><br><span class="line">.addRadius(@r:10px)&#123;  &#x2F;&#x2F;也可以设置默认值</span><br><span class="line">    border-radius: @r;</span><br><span class="line">    -wekit-border-radius: @r;</span><br><span class="line">    -moz-border-radius: @r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用样式</span><br><span class="line">div &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    .addRadius(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p> 可以实现选择器的继承，可以减少代码量，同时使代码结构更加清晰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.jd_hearder &#123;&#125;</span><br><span class="line">.jd_hearder &gt; div &#123;&#125;</span><br><span class="line">.jd_hearder &gt; div &gt; h3 &#123;&#125;</span><br><span class="line">.jd_hearder &gt; div &gt; h3::before &#123;&#125;</span><br><span class="line">.jd_hearder&gt; div &gt; a:hover &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面是我们之前常用的写样式的方式，代码是非常冗余的，并且结构不清晰；</p><p>可以用less来解决这类问题，并且编译后的css文件，与上面的代码的效果是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.jd_header &#123;</span><br><span class="line">    width: 100%；</span><br><span class="line">        height: 200px;</span><br><span class="line">    .addRadius();</span><br><span class="line">    &#x2F;&#x2F;嵌套一个元素</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        h3 &#123;</span><br><span class="line">            height: 200px;</span><br><span class="line">            ::before    &#x2F;&#x2F;相当于 h3 ::before</span><br><span class="line">            $::before &#123;&#125;&#x2F;&#x2F;相当于 h3::before     注意区别</span><br><span class="line">        &#125;</span><br><span class="line">        a &#123;</span><br><span class="line">            color: @baseColor;</span><br><span class="line">            $:hover &#123;   &#x2F;&#x2F;相当于 a:hover</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Less&quot;&gt;&lt;a href=&quot;#Less&quot; class=&quot;headerlink&quot; title=&quot;Less&quot;&gt;&lt;/a&gt;Less&lt;/h1&gt;&lt;p&gt;less是动态的样式表&lt;strong&gt;语言&lt;/strong&gt;，通过简明的语法定义，使编写cs’s的工作变得非常简单，本质上，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于浮动的若干问题</title>
    <link href="http://example.com/2021/03/11/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/03/11/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-11T11:52:41.000Z</published>
    <updated>2021-03-11T11:53:42.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-标准文档流"><a href="#1-标准文档流" class="headerlink" title="1.标准文档流"></a>1.标准文档流</h1><p>标准流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做标准流布局。</p><h1 id="2-浮动"><a href="#2-浮动" class="headerlink" title="2.浮动"></a>2.浮动</h1><h2 id="2-1-浮动的机制"><a href="#2-1-浮动的机制" class="headerlink" title="2.1 浮动的机制"></a>2.1 浮动的机制</h2><p>当有两个div同时在标准刘文档中的时候，两个div会隔行显示：</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img1.png" alt="img1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(2D图)</span><br></pre></td></tr></table></figure><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img4.png" alt="img4"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**（3D图）**</span><br></pre></td></tr></table></figure><p>当将蓝色div对应的CSS添加浮动属性后，蓝色div会脱离标准流，而浮在标准流之上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float: left;</span><br></pre></td></tr></table></figure><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img2.png" alt="img2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**（2D图）**</span><br></pre></td></tr></table></figure><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img5.png" alt="img5"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**（3D图）**</span><br></pre></td></tr></table></figure><p>将蓝色div和红色div同时设置浮动属性后，两者都处于浮动的层次，显示方式默认为贴边水平并排显示</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img3.png" alt="img3"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**（2D图）**</span><br></pre></td></tr></table></figure><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img6.png" alt="img6"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**（3D图）**</span><br></pre></td></tr></table></figure><h2 id="2-2-浮动的使用"><a href="#2-2-浮动的使用" class="headerlink" title="2.2 浮动的使用"></a>2.2 浮动的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;float:属性值;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">元素向左浮动</td></tr><tr><td align="center">right</td><td align="center">元素向右浮动</td></tr><tr><td align="center">none</td><td align="center">元素不浮动（默认值）</td></tr></tbody></table><h2 id="2-3-清除浮动"><a href="#2-3-清除浮动" class="headerlink" title="2.3 清除浮动"></a>2.3 清除浮动</h2><h3 id="2-3-1-为什么要清除浮动"><a href="#2-3-1-为什么要清除浮动" class="headerlink" title="2.3.1 为什么要清除浮动"></a>2.3.1 为什么要清除浮动</h3><p>浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现。</p><p>由于<strong>浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响</strong>，为了解决这些问题，此时就需要在该元素中清除浮动。</p><p>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></p><h3 id="2-3-2-清除浮动的本质"><a href="#2-3-2-清除浮动的本质" class="headerlink" title="2.3.2 清除浮动的本质"></a>2.3.2 清除浮动的本质</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img7.jpg" alt="img7"></p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img8.jpg" alt="img8"></p><h3 id="2-3-3-清除浮动的方法"><a href="#2-3-3-清除浮动的方法" class="headerlink" title="2.3.3 清除浮动的方法"></a>2.3.3 清除浮动的方法</h3><h4 id="1-用clear属性清除浮动"><a href="#1-用clear属性清除浮动" class="headerlink" title="1)用clear属性清除浮动"></a>1)用clear属性清除浮动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;clear:属性值;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td align="center">right</td><td align="center">不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td align="center">both</td><td align="center">同时清除左右两侧浮动的影响</td></tr></tbody></table><h4 id="2-额外标签法"><a href="#2-额外标签法" class="headerlink" title="2)额外标签法"></a>2)额外标签法</h4><p>在浮动元素末尾添加一个大小为0，内容为空的标签，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;clear:both&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>（不推荐）</strong></p><h4 id="3-父级添加overflow属性方法"><a href="#3-父级添加overflow属性方法" class="headerlink" title="3)父级添加overflow属性方法"></a>3)父级添加overflow属性方法</h4><p>给父级元素添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow： hidden；  &#x2F;*auto、scroll都可以*&#x2F;</span><br></pre></td></tr></table></figure><h4 id="4-使用after伪元素清除浮动"><a href="#4-使用after伪元素清除浮动" class="headerlink" title="4) 使用after伪元素清除浮动"></a>4) 使用after伪元素清除浮动</h4><p><strong>:after 方式为空元素的升级版，好处是不用单独加标签了</strong> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after &#123;  content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden;  &#125;   </span><br><span class="line">.clearfix &#123;*zoom: 1;&#125;   &#x2F;*IE6、7 专有 ，星号表示IE7之下浏览器识别，其他浏览器不识别*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*然后给父元素加上clearfix类就可以了*&#x2F;</span><br></pre></td></tr></table></figure><h4 id="5-使用before和after双伪元素清除浮动"><a href="#5-使用before和after双伪元素清除浮动" class="headerlink" title="5)使用before和after双伪元素清除浮动"></a>5)使用before和after双伪元素清除浮动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::before,.clearfix::after &#123; </span><br><span class="line">  content:&quot;&quot;;</span><br><span class="line">  display:table;  </span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">  *zoom:1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*然后给父元素加上clearfix类就可以了*&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-标准文档流&quot;&gt;&lt;a href=&quot;#1-标准文档流&quot; class=&quot;headerlink&quot; title=&quot;1.标准文档流&quot;&gt;&lt;/a&gt;1.标准文档流&lt;/h1&gt;&lt;p&gt;标准流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>去重算法</title>
    <link href="http://example.com/2021/03/11/%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/03/11/%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-11T11:34:22.000Z</published>
    <updated>2021-03-12T07:08:33.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-遍历数组法"><a href="#1-遍历数组法" class="headerlink" title="1.遍历数组法"></a><strong>1.遍历数组法</strong></h3><p>它是最简单的数组去重方法（indexOf方法）</p><p>实现思路：新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">var arr&#x3D;[2,8,5,0,5,2,6,7,2];</span><br><span class="line">function unique1(arr)&#123;</span><br><span class="line">  var hash&#x3D;[];</span><br><span class="line">  for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(hash.indexOf(arr[i])&#x3D;&#x3D;-1)&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数组下标判断法"><a href="#2-数组下标判断法" class="headerlink" title="2.数组下标判断法"></a><strong>2.数组下标判断法</strong></h3><p>调用indexOf方法，性能和方法1差不多</p><p>实现思路：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">function unique2(arr)&#123;</span><br><span class="line">  var hash&#x3D;[];</span><br><span class="line">  for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(arr.indexOf(arr[i])&#x3D;&#x3D;i)&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-排序后相邻去除法"><a href="#3-排序后相邻去除法" class="headerlink" title="3.排序后相邻去除法"></a><strong>3.排序后相邻去除法</strong></h3><p>实现思路：给传入的数组排序，排序后相同的值会相邻，然后遍历排序后数组时，新数组只加入不与前一值重复的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">function unique3(arr)&#123;</span><br><span class="line">  arr.sort();</span><br><span class="line">  var hash&#x3D;[arr[0]];</span><br><span class="line">  for (var i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(arr[i]!&#x3D;hash[hash.length-1])&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-优化遍历数组法"><a href="#4-优化遍历数组法" class="headerlink" title="4.优化遍历数组法"></a><strong>4.优化遍历数组法</strong></h3><p>实现思路：双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length</p><p>将没重复的右边值放入新数组。（检测到有重复值时终止当前循环同时进入外层循环的下一轮判断）</p><p>quan_lst 里面是一个一个的js字面量对象，根据json里面的属性进行判定去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">function unique(quan_lst)&#123;    </span><br><span class="line">&#x2F;&#x2F;去掉重复选取的数据</span><br><span class="line">    for (var i &#x3D; 0; i &lt; quan_lst.length; i++) &#123;</span><br><span class="line">        for (var j &#x3D;i+1; j &lt;quan_lst.length; ) &#123;</span><br><span class="line">            if (quan_lst[i].photoid &#x3D;&#x3D; quan_lst[j].photoid ) &#123;&#x2F;&#x2F;通过photoid属性进行匹配；</span><br><span class="line">                quan_lst.splice(j, 1);&#x2F;&#x2F;去除重复的对象；</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-ES6实现"><a href="#5-ES6实现" class="headerlink" title="5.ES6实现"></a><strong>5.ES6实现</strong></h3><p>基本思路：ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">function unique5(arr)&#123;</span><br><span class="line">  var x &#x3D; new Set(arr);</span><br><span class="line"> return [...x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：如果重复，则去掉该元素</p><p>数组下标去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">function unique22(arr)&#123;</span><br><span class="line">  var hash&#x3D;[];</span><br><span class="line">  for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">     if(arr.indexOf(arr[i])&#x3D;&#x3D;arr.lastIndexOf(arr[i]))&#123;</span><br><span class="line">      hash.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：原先自己一直以为indexOf是针对字符串，原来indexOf也可以查询出数组元素所在的数组中的位置(以0开始计算),</p><h3 id="6-ES6实现（第二种方式）"><a href="#6-ES6实现（第二种方式）" class="headerlink" title="6.ES6实现（第二种方式）"></a><strong>6.ES6实现</strong>（第二种方式）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1,1,8,8,12,12,15,15,16,16];</span><br><span class="line"></span><br><span class="line">function unique (arr) &#123;</span><br><span class="line">return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(unique(arr))</span><br><span class="line">&#x2F;&#x2F;[1,8,12,15,16]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-利用includes"><a href="#7-利用includes" class="headerlink" title="7.利用includes"></a><strong>7.利用includes</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">if (!Array.isArray(arr)) &#123;</span><br><span class="line">console.log(‘type error!’)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">var array &#x3D;[];</span><br><span class="line">for(var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">if( !array.includes( arr[i]) ) &#123;&#x2F;&#x2F;includes 检测数组是否有某个值</span><br><span class="line">array.push(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return array</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique(arr))</span><br></pre></td></tr></table></figure><h3 id="8-利用filter"><a href="#8-利用filter" class="headerlink" title="8.利用filter"></a>8.利用filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 1, 8, 8, 12, 12, 15, 15, 16, 16];</span><br><span class="line">function unlink(arr) &#123;</span><br><span class="line">return arr.filter(function (item, index, arr) &#123;</span><br><span class="line">&#x2F;&#x2F;当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素</span><br><span class="line">return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(unlink(arr));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-遍历数组法&quot;&gt;&lt;a href=&quot;#1-遍历数组法&quot; class=&quot;headerlink&quot; title=&quot;1.遍历数组法&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.遍历数组法&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;它是最简单的数组去重方法（indexOf方法）&lt;/p&gt;
&lt;p&gt;实现</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/2020/05/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2020/05/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-05-11T14:14:21.000Z</published>
    <updated>2021-03-12T07:07:47.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则就是对字符串进行查找、匹配、替换等操作的一串“规则字符串”</p><p>使用方法：在一对斜杠之间添加正则表达式 如：**/** 正则表达式 <strong>/</strong></p><h2 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h2><ul><li>普通字符</li><li>特殊字符（元字符）：正则表达式中具有特殊意义的字符</li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th><strong>\d</strong></th><th><strong>表示数字</strong></th></tr></thead><tbody><tr><td><strong>\D</strong></td><td><strong>非数字</strong></td></tr><tr><td><strong>\s</strong></td><td><strong>空格符</strong></td></tr><tr><td><strong>\S</strong></td><td><strong>非空格符</strong></td></tr><tr><td><strong>\w</strong></td><td><strong>字母或数字或下划线</strong></td></tr><tr><td><strong>\W</strong></td><td><strong>非字母、数字、下划线</strong></td></tr><tr><td><strong>.</strong></td><td><strong>任意字符（不包含换行符）</strong></td></tr><tr><td><strong>\b</strong></td><td><strong>单词边界</strong></td></tr></tbody></table><p>实例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\d&#x2F;; &#x2F;&#x2F;新建一个正则对象</span><br><span class="line"> var str &#x3D; &#39;1&#39;;</span><br><span class="line">console.log(reg.test(str)); &#x2F;&#x2F;true  str中含有数字</span><br><span class="line">&#x2F;&#x2F;test()是正则对象中的一个方法，它会判断str是否满足正则表达式，返回boolean</span><br></pre></td></tr></table></figure><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定之前表达式出现的次数</p><table><thead><tr><th>*****</th><th><strong>重复0次或多次</strong></th></tr></thead><tbody><tr><td><strong>+</strong></td><td><strong>重复1次或多次</strong></td></tr><tr><td><strong>？</strong></td><td><strong>重复0次或1次</strong></td></tr><tr><td><strong>{n}</strong></td><td><strong>重复n次 (连续)</strong></td></tr><tr><td><strong>{n,}</strong></td><td><strong>重复至少n次 (连续)</strong></td></tr><tr><td><strong>{n,m}</strong></td><td><strong>重复n到m次 (连续)</strong></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\d*&#x2F;;</span><br><span class="line">console.log(reg.test(&#39;w&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;12&#39;));&#x2F;&#x2F;true</span><br><span class="line">var reg &#x3D; &#x2F;\d+&#x2F;;</span><br><span class="line">console.log(reg.test(&#39;w&#39;));&#x2F;&#x2F;false</span><br><span class="line">console.log(reg.test(&#39;12&#39;));&#x2F;&#x2F;true</span><br><span class="line">var reg &#x3D; &#x2F;\d?&#x2F;;</span><br><span class="line">console.log(reg.test(&#39;w&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;12&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;w12&#39;));&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;这里12出现了两次，不满足“重复0次或1次”的条件为什么显示为true呢？</span><br><span class="line">&#x2F;&#x2F;当执行test()时，只要字符串中有部分满足条件则返回true）</span><br><span class="line">&#x2F;&#x2F;解决办法var reg &#x3D; &#x2F;^\d?$&#x2F;;  加上开始结束符（后面会介绍）</span><br><span class="line">var reg &#x3D; &#x2F;\d&#123;2&#125;&#x2F;;&#x2F;&#x2F;&#123;n&#125;</span><br><span class="line">console.log(reg.test(&#39;2&#39;));&#x2F;&#x2F;false</span><br><span class="line">console.log(reg.test(&#39;23&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;2w3&#39;));&#x2F;&#x2F;false  不连续时匹配失败</span><br><span class="line">console.log(reg.test(&#39;234&#39;));&#x2F;&#x2F;true  (理应为false)原因同上</span><br><span class="line">console.log(reg.test(&#39;ab234&#39;));&#x2F;&#x2F;true  (理应为false)原因同上  解决办法同上</span><br><span class="line">var reg &#x3D; &#x2F;\d&#123;2,&#125;&#x2F;;&#x2F;&#x2F;&#123;n,&#125;  &#x2F;&#x2F;同样存在以上问题</span><br><span class="line">var reg &#x3D; &#x2F;\d&#123;2,6&#125;&#x2F;;&#x2F;&#x2F;&#123;n,m&#125;  &#x2F;&#x2F;同样存在以上问题</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="范围符"><a href="#范围符" class="headerlink" title="范围符[ ]"></a>范围符[ ]</h2><p>1、[a-z]、[A-Z]、[0-9],也可以综合写成[a-zA-Z0-9]；当然这范围是自己定义的，比如[a-b]，范围是a到b。</p><p>2、[\u4e00-\u9fa5] 匹配汉字的范围 其中\u4e00，\u9fa5是中日韩汉字Unicode表中对应的编码 4e00对应“一” 9fa5对应“龥”</p><p><a href="http://www.chi2ko.com/tool/CJK.htm">中日韩汉字Unicode表</a></p><p>3、[ab5&amp;@],仅匹配 a 或 b 或 5 或 &amp; 或 @</p><p>4、**[^ab5&amp;@]** 匹配除 a 或 b 或 5 或 &amp; 或 @之外的内容 （注意此处^是在[ ]内的，<strong>区别于开始符^</strong>,两者所处位置不同）</p><p>5、3 | a 匹配3或者a字符</p><h2 id="开始结束符号"><a href="#开始结束符号" class="headerlink" title="开始结束符号"></a>开始结束符号</h2><table><thead><tr><th><strong>^</strong></th><th><strong>开始符（强制规定匹配开始的地方）</strong></th></tr></thead><tbody><tr><td><strong>$</strong></td><td><strong>结束符（强制规定匹配结束的地方）</strong></td></tr></tbody></table><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^\d 字符串要以数字开始，数字只能出现一次</span><br><span class="line">\d$  字符串要以数字结束，数字只能出现一次</span><br><span class="line">^\d$  字符串要以数字开始和结束，数字只能出现一次</span><br><span class="line">\d+$  字符串要以数字开始，以数字结束，数字只能出现一次</span><br><span class="line">^\d?$  字符串要以数字开头和结束，数字出现0次或1次</span><br></pre></td></tr></table></figure><p>我们来解释 <strong>var reg = /\d?/;</strong> 例子中出现的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\d?&#x2F;;</span><br><span class="line">console.log(reg.test(&#39;w&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;12&#39;));&#x2F;&#x2F;开始检测，当检测到 1 时，因为满足了数字出现0次，匹配成功，返回true，此时结束位置在1和2之间</span><br><span class="line">&#x2F;&#x2F;加入开始结束符</span><br><span class="line">var reg &#x3D; &#x2F;^\d?$&#x2F;;</span><br><span class="line">console.log(reg.test(&#39;w&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;12&#39;));&#x2F;&#x2F;当加入开始结束字符后，开始匹配位置强制从1开始 2结束</span><br><span class="line">&#x2F;&#x2F;则12是由两个数字的  不符合“重复0次或1次”的条件，则为false</span><br></pre></td></tr></table></figure><p>我们来解释 <strong>var reg = /\d{2}/;</strong> 例子中出现的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\d&#123;2&#125;&#x2F;;&#x2F;&#x2F;&#123;n&#125;</span><br><span class="line">console.log(reg.test(&#39;2&#39;));&#x2F;&#x2F;false</span><br><span class="line">console.log(reg.test(&#39;23&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;234&#39;));&#x2F;&#x2F;true  开始字符为2  结束字符为3</span><br><span class="line">console.log(reg.test(&#39;ww234&#39;));&#x2F;&#x2F;true 开始字符为2  结束字符为3</span><br><span class="line">var reg &#x3D; &#x2F;^\d&#123;2&#125;$&#x2F;;&#x2F;&#x2F;&#123;n&#125;</span><br><span class="line">console.log(reg.test(&#39;2&#39;));&#x2F;&#x2F;false</span><br><span class="line">console.log(reg.test(&#39;23&#39;));&#x2F;&#x2F;true</span><br><span class="line">console.log(reg.test(&#39;234&#39;));&#x2F;&#x2F;false  开始字符为2  结束字符为4</span><br><span class="line">console.log(reg.test(&#39;ab234&#39;));&#x2F;&#x2F;false 开始字符为a  结束字符为4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正则对象的创建方式"><a href="#正则对象的创建方式" class="headerlink" title="正则对象的创建方式"></a>正则对象的创建方式</h2><h3 id="1、new-RegExp"><a href="#1、new-RegExp" class="headerlink" title="1、new RegExp()"></a>1、new RegExp()</h3><p>RegExp(reg,msg) 参数一：正则表达式</p><p>参数二：附加条件（如：i 忽略大小写，g 全局匹配）</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; new RegExp(&#39;\\w+&#39;,&#39;ig&#39;);  &#x2F;&#x2F;注意，此处第一个\是转义字符，因为参数一不能直接传入正则表达式</span><br><span class="line">var reg &#x3D; new RegExp(&#39;[a-z]&#39;,&#39;ig&#39;);</span><br><span class="line">var str &#x3D; &quot;AaaC2_&quot;;</span><br><span class="line">console.log(reg.test(str));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h3 id="2、简写"><a href="#2、简写" class="headerlink" title="2、简写"></a>2、简写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;[a-z]&#x2F;ig;</span><br><span class="line">var str &#x3D; &quot;AaaC2_&quot;;</span><br><span class="line">console.log(reg.test(str));&#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正则对象的方法"><a href="#正则对象的方法" class="headerlink" title="正则对象的方法"></a>正则对象的方法</h2><p>RegExp.test(‘字符串’); 判断字符串知否满足正则表达式 返回布尔值</p><p>RegExp.exec(‘字符串’); 判断字符串知否满足正则表达式 将找到的内容以数组的形式返回</p><p>1、不使用 “<code>g</code>“ 标志时,每次都返回第一个找的内容 而不继续向后查找</p><p>2、当正则表达式使用 “<code>g</code>“ 标志时，可以多次执行 <code>exec</code> 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>lastIndex</code></a> 属性指定的位置开始</p><p><strong>lastIndex</strong>:</p><p>只有正则表达式使用了表示全局检索的 “<code>g</code>“ 标志时，该属性才会起作用。此时应用下面的规则：</p><ul><li>如果 <code>lastIndex</code> 大于字符串的长度，则 <code>regexp.test</code> 和 <code>regexp.exec</code> 将会匹配失败，然后 <code>lastIndex</code> 被设置为 0。</li><li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 <code>lastIndex</code> 开始的字符串。（then the regular expression matches input starting at <code>lastIndex</code>.）</li><li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，<code>lastIndex</code> 被设置为 0.。</li><li>否则，<code>lastIndex</code> 被设置为紧随最近一次成功匹配的下一个位置。</li></ul><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;找出所有三个英文字母组成的  并且以A开头的单词</span><br><span class="line">var str &#x3D; &#39;Asd Asss wes sgetgs x Adv Wdf&#39;;</span><br><span class="line">var reg &#x3D; &#x2F;\bA[A-Za-z]&#123;2&#125;\b&#x2F;g;</span><br><span class="line">console.log(reg.lastIndex);&#x2F;&#x2F;初始值为0</span><br><span class="line">var word &#x3D; reg.exec(str);&#x2F;&#x2F;￥1￥</span><br><span class="line">console.log(reg.lastIndex);&#x2F;&#x2F;3</span><br><span class="line">while(word)&#123;</span><br><span class="line">    console.log(word);</span><br><span class="line">    word &#x3D; reg.exec(str);&#x2F;&#x2F;￥2￥</span><br><span class="line">    console.log(reg.lastIndex);</span><br><span class="line">&#125;</span><br><span class="line">onsole.log(word);&#x2F;&#x2F;null</span><br><span class="line">console.log(reg.lastIndex);&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure><p>该函数运行的实质：exec每一次执行都有开始位置，而这个开始位置是由RegExp对象的lastIndex属性值所决定的；</p><p>以下为该段代码的执行顺序与解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、reg.lastIndex 的初始值为0</span><br><span class="line">2、执行￥1￥处的exec时，当前的lastIndex数值为0，则exec从字符串的0位置（即A字符）开始。执行结束，将**所找的字符串**（Asd）以数组的形式返回给word，并修改reg.lastIndex的值为&quot; **所找到的字符串最后一个的位置的下一个位置** &quot;（也就是d下标加一，为3），</span><br><span class="line">3、执行while循环，word此时为[Asd]数组，while语句判断成功</span><br><span class="line">4、执行￥2￥处的exec，此时reg.lastIndex为3，则从字符串中下标为3的字符开始执行，找到 &quot;Adv&quot;,  v的下标为24，则reg.lastIndex的值被设置为25，word此时为[Adv]数组</span><br><span class="line">5、判断while 成功</span><br><span class="line">6、执行￥2￥处的exec，此时reg.lastIndex为25，则从字符串中下标为25的字符开始执行，未找到满足条件的内容，则返回null给word，并将reg.lastIndex设为0；</span><br><span class="line">7、判断while,此时word为null，判断失败，则跳出循环</span><br><span class="line">8、程序结束</span><br></pre></td></tr></table></figure><h2 id="懒惰模式与贪婪模式"><a href="#懒惰模式与贪婪模式" class="headerlink" title="懒惰模式与贪婪模式"></a>懒惰模式与贪婪模式</h2><p>懒惰模式：在满足条件的前提下，尽可能<strong>少</strong>的匹配字符</p><p>贪婪模式：在满足条件的前提下，尽可能<strong>多</strong>的匹配字符</p><p>正则表达式的量词有：* + ？ {}</p><p>量词默认是贪婪模式，当在量词之后加上?时，将贪婪模式转换为懒惰模式。</p><h2 id="分组提取"><a href="#分组提取" class="headerlink" title="分组提取"></a>分组提取</h2><p>正则中（）表示分组</p><p>若存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((((a))((b)))(c))</span><br></pre></td></tr></table></figure><p>则第一组；(((a))((b)))(c)</p><p>第二组：((a))</p><p>第三组：(a)</p><p>第四组：(b)</p><p>第五组：(c)</p><p>找法：从左往右找左括号(</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;((\d+)(\w+))&#x2F;;</span><br><span class="line">var str &#x3D; &quot;123abc_c&quot;</span><br><span class="line">if(reg.test(str))&#123;</span><br><span class="line">    &#x2F;&#x2F;$后的数字 类似数组的下标</span><br><span class="line">    console.log(RegExp.$1);&#x2F;&#x2F;获得第一组(\d+)(\w+)的内容  则是123abc_c</span><br><span class="line">    console.log(RegExp.$2);&#x2F;&#x2F;获得第二组(\d+)的内容  则是123</span><br><span class="line">    console.log(RegExp.$3);&#x2F;&#x2F;获得第二组(\w+)的内容  则是abc_c</span><br><span class="line">&#125;</span><br><span class="line">字符串</span><br></pre></td></tr></table></figure><h2 id="字符串中正则的使用"><a href="#字符串中正则的使用" class="headerlink" title="字符串中正则的使用"></a>字符串中正则的使用</h2><p>方法：</p><table><thead><tr><th><strong>String.match(正则对象)</strong></th><th><strong>返回符合正则条件的集合</strong></th></tr></thead><tbody><tr><td><strong>String.replace(正则对象,”替换的字符串”)</strong></td><td><strong>替换字符串，若要全局替换，正则对象要加g</strong></td></tr><tr><td><strong>String.search(正则对象)</strong></td><td><strong>查找字符串，返回查找内容的第一次出现的位置</strong></td></tr><tr><td><strong>String.split(正则对象)</strong></td><td><strong>切割字符串，返回切割后的数组</strong></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;match</span><br><span class="line">var str&#x3D;&quot;abc123ee23f90&quot;;</span><br><span class="line">&#x2F;&#x2F;将字符串中所有出现的每一个数字提取出来</span><br><span class="line">var arr &#x3D;  str.match(&#x2F;\d&#x2F;g);</span><br><span class="line">console.log(arr);</span><br><span class="line">&#x2F;&#x2F;将字符串中所有出现的连续的数字提取出来</span><br><span class="line">var arr &#x3D;  str.match(&#x2F;\d+&#x2F;g);</span><br><span class="line">console.log(arr);</span><br><span class="line">&#x2F;&#x2F;replace</span><br><span class="line">&#x2F;&#x2F;替换所有 - +</span><br><span class="line">var str &#x3D; &quot;a-b-+b-c&quot;;</span><br><span class="line">console.log(str.replace(&#x2F;-|\+&#x2F;g,&quot;*&quot;));&#x2F;&#x2F;结果a*b**b*c</span><br><span class="line">&#x2F;&#x2F;若不加g  则结果为a*b-+b-c</span><br><span class="line">&#x2F;&#x2F;search</span><br><span class="line">&#x2F;&#x2F;忽略大小写  找到第一个b的下标</span><br><span class="line">var str &#x3D; &quot;a-b-b-c&quot;;</span><br><span class="line">console.log(str.search(&#x2F;B&#x2F;i));&#x2F;&#x2F;结果2</span><br><span class="line">&#x2F;&#x2F;split</span><br><span class="line">var str&#x3D;&quot;a|b|c|&quot;;</span><br><span class="line">console.log(str.split(&#x2F;\|&#x2F;));&#x2F;&#x2F;结果  &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;正则就是对字符串进行查找、匹配、替换等操作的一串“规则字符串”&lt;/p&gt;
&lt;p&gt;使用方法：在一对斜杠之间添加正则表达式</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深拷贝</title>
    <link href="http://example.com/2020/05/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/2020/05/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-05-11T01:46:53.000Z</published>
    <updated>2021-03-12T07:08:12.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>//创建一个对象<br>var obj1 = {<br>age:10,<br>sex:”女”,<br>car:[“法拉利”,”布加迪威龙”,”玛莎拉蒂”],//数组<br>dog:{//对象属性<br>name:”贝贝”,<br>age:8,<br>color:”棕色”<br>}<br>};<br>//创建另外一个对象<br>var obj2 = {};//空对象<br>/<em>console.log(obj2);</em>/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;封装一个拷贝逻辑的函数,把对象a中的数据复制到对象b中</span><br><span class="line">function extend(a,b)&#123;</span><br><span class="line">    for(var key in a)&#123;&#x2F;&#x2F;从a对象中复制</span><br><span class="line">        &#x2F;&#x2F;1.获取到a对象中所有的属性的值</span><br><span class="line">        var item &#x3D; a[key];&#x2F;&#x2F;item是一个数组,封装了普通属性,数组,对象</span><br><span class="line">        &#x2F;&#x2F;2.判断这个属性的值是不是数组-是数组就要遍历</span><br><span class="line">        if(item instanceof Array)&#123;&#x2F;&#x2F;过滤是否是数组</span><br><span class="line">            &#x2F;&#x2F;在对象b中开辟一个空间 - 数组</span><br><span class="line">            b[key] &#x3D; [];&#x2F;&#x2F;空数组</span><br><span class="line">            &#x2F;&#x2F;调用这个函数,把a对象中的数组的属性一个个复制到b对象的数组中</span><br><span class="line">            extend(item,b[key]);&#x2F;&#x2F;item封装的是数组</span><br><span class="line">        &#125;else if(item instanceof Object)&#123;&#x2F;&#x2F;如果是对象</span><br><span class="line">            &#x2F;&#x2F;在b对象中创建一个对象 - 空的</span><br><span class="line">            b[key] &#x3D; &#123;&#125;;&#x2F;&#x2F;空对象</span><br><span class="line">            &#x2F;&#x2F;调用这个函数,把a对象中的对象的属性一个个复制到b对象的对象中</span><br><span class="line">            extend(item,b[key]);&#x2F;&#x2F;item封装的是对象</span><br><span class="line">        &#125;else&#123;&#x2F;&#x2F;普通属性</span><br><span class="line">            b[key] &#x3D; item;&#x2F;&#x2F;这一行是传复制对象与数组里面的值，也是递归的结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用方法,实现深拷贝</span><br><span class="line">extend(obj1,obj2);</span><br><span class="line">console.dir(obj2);&#x2F;&#x2F;原来是空对象</span><br><span class="line">console.dir(obj1);</span><br></pre></td></tr></table></figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;演示浅拷贝</span><br><span class="line">        &#x2F;&#x2F;对象</span><br><span class="line">        var obj1 &#x3D; &#123;</span><br><span class="line">            age:10,</span><br><span class="line">            sex:&quot;男&quot;,</span><br><span class="line">            car:[&quot;三轮车&quot;,&quot;黄包车&quot;,&quot;摩托车&quot;]</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;设置一个空对象 - 对象是存在的,但是没有内容</span><br><span class="line">        var obj2 &#x3D; &#123;&#125;;</span><br><span class="line">        &#x2F;&#x2F;console.log(obj2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;封装一个函数,作用是把一个对象中的属性复制给另一个对象 - 浅拷贝</span><br><span class="line">        function extend(a,b)&#123;&#x2F;&#x2F;把a对象中所有的属性复制给b对象</span><br><span class="line">            &#x2F;&#x2F;利用for循环处理 - 没有下标 - for-in</span><br><span class="line">            for(var key in a)&#123;</span><br><span class="line">                b[key] &#x3D; a[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用这个函数,实现浅拷贝</span><br><span class="line">        extend(obj1,obj2);</span><br><span class="line">        console.log(obj2);</span><br><span class="line">        console.log(obj1);</span><br></pre></td></tr></table></figure><h2 id="遍历dom树"><a href="#遍历dom树" class="headerlink" title="遍历dom树"></a>遍历dom树</h2><p><strong>html部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;遍历DOM树&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p style&#x3D;&quot;color:green;&quot;&gt;Tip:可以在遍历的回调函数中任意的定制需求&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;123&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li&gt;456&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li&gt;789&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;span&gt;哈啊哈哈哈哈哈&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id&#x3D;&quot;demo_node&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;123&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;p&gt;hello&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;h2&gt;world&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;asdfg&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;h3&gt;</span><br><span class="line">                &lt;span&gt;jfkldsaufoiasdj&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.获取页面中的根节点</span><br><span class="line">        var root &#x3D; document.documentElement;&#x2F;&#x2F;html</span><br><span class="line">        &#x2F;&#x2F;函数遍历DOM</span><br><span class="line">        &#x2F;&#x2F;根据根节点,调用fn函数,显示根节点的名字</span><br><span class="line">        function forDOM(root1)&#123;&#x2F;&#x2F;传入一个形参</span><br><span class="line">            &#x2F;&#x2F;获取根节点中给所有的子节点</span><br><span class="line">            var children &#x3D; root1.children;</span><br><span class="line">            &#x2F;&#x2F;遍历所有的子节点</span><br><span class="line">            forChildren(children);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;封装一个函数:给我所有的子节点,把这个子节点中的所有的子节点显示出来</span><br><span class="line">        function forChildren(children)&#123;</span><br><span class="line">            &#x2F;&#x2F;遍历所有的子节点</span><br><span class="line">            for(var i&#x3D;0;i&lt;children.length;i++)&#123;</span><br><span class="line">                &#x2F;&#x2F;获取到每一个子节点</span><br><span class="line">                var child &#x3D; children[i];</span><br><span class="line">                &#x2F;&#x2F;显示每一个子节点的名字</span><br><span class="line">                f1(child);</span><br><span class="line">                &#x2F;&#x2F;判断child下还有没有子节点,如果有,则继续遍历</span><br><span class="line">                child.children&amp;&amp;forDOM(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用函数,传入根节点</span><br><span class="line">        forDOM(root);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;显示节点的名字</span><br><span class="line">        function f1(node)&#123;</span><br><span class="line">            console.log(&quot;节点的名字: &quot; + node.nodeName);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深拷贝&quot;&gt;&lt;a href=&quot;#深拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝&quot;&gt;&lt;/a&gt;深拷贝&lt;/h2&gt;&lt;p&gt;//创建一个对象&lt;br&gt;var obj1 = {&lt;br&gt;age:10,&lt;br&gt;sex:”女”,&lt;br&gt;car:[“法拉利”,”布加迪</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于input禁用中文输入法的问题</title>
    <link href="http://example.com/2020/04/17/%E5%85%B3%E4%BA%8Einput%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/04/17/%E5%85%B3%E4%BA%8Einput%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-17T15:55:08.000Z</published>
    <updated>2021-03-12T06:51:14.591Z</updated>
    
    <content type="html"><![CDATA[<p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;input&quot;&gt;</span><br><span class="line">    &lt;!-- &lt;input type&#x3D;&quot;tel&quot;&gt; --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var input &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">        input.onkeydown &#x3D; function(e)&#123; &#x2F;&#x2F;检测键入的键的ASCLL码值</span><br><span class="line">            var event &#x3D; e || window.event;</span><br><span class="line">            if(event.keyCode !&#x3D; 8 &amp;&amp; (event.keyCode &lt; 48 || event.keyCode &gt; 57))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return true;   &#x2F;&#x2F;中文输入法的兼容性问题  如何禁用中文输入法</span><br><span class="line">        &#125;</span><br><span class="line">        var cpLock &#x3D; false;&#x2F;&#x2F;默认中文输入法关闭</span><br><span class="line">        &#x2F;&#x2F;中文输入法开始时触发compositionstart事件</span><br><span class="line">        document.addEventListener(&#39;compositionstart&#39;,function(e)&#123;</span><br><span class="line">                cpLock &#x3D; true;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;中文输入法结束时触发compositionend事件</span><br><span class="line">        document.addEventListener(&#39;compositionend&#39;,function(e)&#123;</span><br><span class="line">                cpLock &#x3D; false;</span><br><span class="line">        &#125;);</span><br><span class="line">        input.oninput &#x3D; function()&#123;</span><br><span class="line">            if(cpLock)&#123;</span><br><span class="line">                &#x2F;&#x2F;将input中的A~Z  a~z都替换成空字符</span><br><span class="line">                this.value &#x3D; this.value.replace(&#x2F;[A-Za-z]&#x2F;g,&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>注意点：1、oninput事件总是后于onkeydown执行</p><p> 2、compositionstart事件，非英文输入法开启时触发；</p><p> 3、compositionend事件，非英文输入法结束时触发；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;完整代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cookie session</title>
    <link href="http://example.com/2020/03/01/cookie-session/"/>
    <id>http://example.com/2020/03/01/cookie-session/</id>
    <published>2020-03-01T01:38:25.000Z</published>
    <updated>2021-03-12T06:46:51.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-cookie --save</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="引入与配置"><a href="#引入与配置" class="headerlink" title="引入与配置"></a>引入与配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;);</span><br><span class="line">&#x2F;&#x2F;中间件 签名</span><br><span class="line">app.use(cookieParser(&#39;howlcn&#39;));</span><br></pre></td></tr></table></figure><h4 id="用cookie储存信息"><a href="#用cookie储存信息" class="headerlink" title="用cookie储存信息"></a>用cookie储存信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(&#39;username&#39;,req.body.username,&#123;</span><br><span class="line">    maxAge:1000*60, &#x2F;&#x2F;cookie失效的时长（单位毫秒）</span><br><span class="line">    signed:true&#x2F;&#x2F;开启签名 方式用户篡改cookie</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="清空cookie"><a href="#清空cookie" class="headerlink" title="清空cookie"></a>清空cookie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.cookie();</span><br></pre></td></tr></table></figure><h4 id="获取cookie中的数据"><a href="#获取cookie中的数据" class="headerlink" title="获取cookie中的数据"></a>获取cookie中的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let username &#x3D; req.signedCookies.username;&#x2F;&#x2F;获取cookie中的username</span><br></pre></td></tr></table></figure><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session底层还是调用了cookie</p><p><a href="https://i.loli.net/2019/05/30/5cef97889476388883.png"><img src="https://i.loli.net/2019/05/30/5cef97889476388883.png" alt="session"></a></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session --save</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="引入与配置-1"><a href="#引入与配置-1" class="headerlink" title="引入与配置"></a>引入与配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const app &#x3D; express();</span><br><span class="line">const expressSession &#x3D; require(&#39;express-session&#39;);</span><br><span class="line">&#x2F;&#x2F;配置expressSession中间件</span><br><span class="line">app.use(expressSession(&#123;</span><br><span class="line">    &#x2F;&#x2F;cookie的名字</span><br><span class="line">    name:&#39;howlcn&#39;,</span><br><span class="line">    &#x2F;&#x2F;cookie签名的信息</span><br><span class="line">    secret:&#39;howlcn&#39;,</span><br><span class="line">    cookie:&#123;</span><br><span class="line">        maxAge:100000</span><br><span class="line">    &#125;,</span><br><span class="line">    resave:false,</span><br><span class="line">    &#x2F;&#x2F;saveUninitialized为true时会将没有初始化的session的数据保存到storage中</span><br><span class="line">    &#x2F;&#x2F;一般没有初始化的session是没有数据的  不必保存  则设置为false</span><br><span class="line">    saveUninitialized: false,</span><br><span class="line">    &#x2F;&#x2F;为true时，某客户端每一次访问都会重置cookie的重置时间(maxAge)</span><br><span class="line">    rolling:true,</span><br><span class="line">    &#x2F;&#x2F;指定session数据存放的地方(数据库),默认保存在服务器内存中（null也是）</span><br><span class="line">    store:null</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h4 id="用session存储数据"><a href="#用session存储数据" class="headerlink" title="用session存储数据"></a>用session存储数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.session.username &#x3D; username;</span><br></pre></td></tr></table></figure><h4 id="清空session"><a href="#清空session" class="headerlink" title="清空session"></a>清空session</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.session.destroy()</span><br></pre></td></tr></table></figure><h4 id="获取session中的信息"><a href="#获取session中的信息" class="headerlink" title="获取session中的信息"></a>获取session中的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let username &#x3D; req.session.username;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h2&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>npm的初步见解</title>
    <link href="http://example.com/2020/02/11/npm%E7%9A%84%E5%88%9D%E6%AD%A5%E8%A7%81%E8%A7%A3/"/>
    <id>http://example.com/2020/02/11/npm%E7%9A%84%E5%88%9D%E6%AD%A5%E8%A7%81%E8%A7%A3/</id>
    <published>2020-02-11T00:24:41.000Z</published>
    <updated>2021-03-12T07:05:09.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm的初步见解"><a href="#npm的初步见解" class="headerlink" title="npm的初步见解"></a>npm的初步见解</h2><h2 id="一-包管理工具"><a href="#一-包管理工具" class="headerlink" title="一. 包管理工具"></a>一. 包管理工具</h2><h3 id="1-1-认识npm"><a href="#1-1-认识npm" class="headerlink" title="1.1. 认识npm"></a>1.1. 认识npm</h3><p>我们已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构：</p><ul><li>在以后的开发中我们就可以通过模块化的方式来封装自己的代码，并且封装成一个工具；</li><li>这个工具我们可以让同事通过导入的方式来使用，甚至你可以分享给世界各地的程序员来使用；</li></ul><p><strong>如果我们分享给世界上所有的程序员使用，有哪些方式呢？</strong></p><p>方式一：上传到GitHub上、其他程序员通过GitHub下载我们的代码手动的引用；</p><ul><li>缺点是大家必须知道你的代码GitHub的地址，并且从GitHub上手动下载；</li><li>需要在自己的项目中手动的引用，并且管理相关的依赖；</li><li>不需要使用的时候，需要手动来删除相关的依赖；</li><li>当遇到版本升级或者切换时，需要重复上面的操作；</li></ul><p>显然，上面的方式是有效的，但是这种传统的方式非常麻烦，并且容易出错；</p><p>方式二：使用一个专业的工具来管理我们的代码</p><ul><li>我们通过工具将代码发布到特定的位置；</li><li>其他程序员直接通过工具来安装、升级、删除我们的工具代码；</li></ul><p>显然，通过第二种方式我们可以更好的管理自己的工具包，其他人也可以更好的使用我们的工具包。</p><p>包管理工具npm：</p><ul><li>Node Package Manager，也就是Node包管理器；</li><li>但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包；</li><li>比如express、koa、react、react-dom、axios、babel、webpack等等；</li></ul><p>npm管理的包可以在哪里查看、搜索呢？</p><ul><li><a href="https://www.npmjs.com/">https://www.npmjs.com/</a></li><li>这是我们安装相关的npm包的官网；</li></ul><p>npm管理的包存放在哪里呢？</p><ul><li>我们发布自己的包其实是发布到registry上面的；</li><li>当我们安装一个包时其实是从registry上面下载的包；</li></ul><h3 id="1-2-项目配置文件"><a href="#1-2-项目配置文件" class="headerlink" title="1.2. 项目配置文件"></a>1.2. 项目配置文件</h3><p>事实上，我们每一个项目都会有一个对应的配置文件，无论是前端项目还是后端项目：</p><ul><li>这个配置文件会记录着你项目的名称、版本号、项目描述等；</li><li>也会记录着你项目所依赖的其他库的信息和依赖库的版本号；</li></ul><p>这个配置文件在Node环境下面（无论是前端还是后端）就是package.json。</p><p>我们以vue cli4脚手架创建的项目为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;my-vue&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;core-js&quot;: &quot;^3.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.11&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-babel&quot;: &quot;~4.5.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,</span><br><span class="line">    &quot;@vue&#x2F;cli-service&quot;: &quot;~4.5.0&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^6.7.2&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;browserslist&quot;: [</span><br><span class="line">    &quot;&gt; 1%&quot;,</span><br><span class="line">    &quot;last 2 versions&quot;,</span><br><span class="line">    &quot;not dead&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上Vue ClI4脚手架创建的项目相对进行了简化，我们来看一下CLI2创建的项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;vuerouterbasic&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A Vue.js project&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;&#39;coderwhy&#39; &lt;&#39;coderwhy@gmail.com&#39;&gt;&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;node build&#x2F;build.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;vue&quot;: &quot;^2.5.2&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.22.1&quot;,</span><br><span class="line">    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,</span><br><span class="line">    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,</span><br><span class="line">    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,</span><br><span class="line">    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,</span><br><span class="line">    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,</span><br><span class="line">    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,</span><br><span class="line">    &quot;chalk&quot;: &quot;^2.0.1&quot;,</span><br><span class="line">    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^0.28.0&quot;,</span><br><span class="line">    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;file-loader&quot;: &quot;^1.1.4&quot;,</span><br><span class="line">    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,</span><br><span class="line">    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,</span><br><span class="line">    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,</span><br><span class="line">    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;ora&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">    &quot;portfinder&quot;: &quot;^1.0.13&quot;,</span><br><span class="line">    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,</span><br><span class="line">    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,</span><br><span class="line">    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,</span><br><span class="line">    &quot;rimraf&quot;: &quot;^2.6.0&quot;,</span><br><span class="line">    &quot;semver&quot;: &quot;^5.3.0&quot;,</span><br><span class="line">    &quot;shelljs&quot;: &quot;^0.7.6&quot;,</span><br><span class="line">    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,</span><br><span class="line">    &quot;url-loader&quot;: &quot;^0.5.8&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,</span><br><span class="line">    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.6.0&quot;,</span><br><span class="line">    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,</span><br><span class="line">    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;&#x3D; 6.0.0&quot;,</span><br><span class="line">    &quot;npm&quot;: &quot;&gt;&#x3D; 3.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;browserslist&quot;: [</span><br><span class="line">    &quot;&gt; 1%&quot;,</span><br><span class="line">    &quot;last 2 versions&quot;,</span><br><span class="line">    &quot;not ie &lt;&#x3D; 8&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以手动创建一个package.json文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm init #创建时填写信息</span><br><span class="line">npm init -y # 所有信息使用默认的</span><br></pre></td></tr></table></figure><p><code>npm init -y</code>生成文件的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;learn-npm&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现属性非常的多，我们这里对一些常见属性进行一些解析。</p><p><strong>必须填写的属性：name、version</strong></p><ul><li>name是项目的名称；</li><li>version是当前项目的版本号；</li><li>description是描述信息，很多时候是作为项目的基本描述；</li><li>author是作者相关信息（发布时用到）；</li><li>license是开源协议（发布时用到）；</li></ul><p><strong>private属性：</strong></p><ul><li>private属性记录当前的项目是否是私有的；</li><li>当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式；</li></ul><p><strong>main属性：</strong></p><ul><li>设置程序的入口。</li><li>很多人会有疑惑，webpack不是会自动找到程序的入口吗？</li><li><ul><li>这个入口和webpack打包的入口并不冲突；</li><li>它是在你发布一个模块的时候会用到的；</li><li>比如我们使用axios模块 <code>const axios = require(&#39;axios&#39;);</code></li><li>实际上是找到对应的main属性查找文件的；</li></ul></li></ul><p><strong>scripts属性</strong></p><ul><li>scripts属性用于配置一些脚本命令，以键值对的形式存在；</li><li>配置后我们可以通过 <code>npm run 命令的key</code>来执行这个命令；</li><li><code>npm start</code>和<code>npm run start</code>的区别是什么？</li><li><ul><li>它们是等价的；</li><li>对于常用的 start、 test、stop、restart可以省略掉run直接通过 <code>npm start</code>等方式运行；</li></ul></li></ul><p><strong>dependencies属性</strong></p><ul><li>dependencies属性是指定无论开发环境还是生成环境都需要依赖的包；</li><li>通常是我们项目实际开发用到的一些库模块；</li><li>与之对应的是devDependencies；</li></ul><p><strong>devDependencies属性</strong></p><ul><li>一些包在生成环境是不需要的，比如webpack、babel等；</li><li>这个时候我们会通过 <code>npm install webpack --save-dev</code>，将它安装到devDependencies属性中；</li></ul><p>疑问：那么在生成环境如何保证不安装这些包呢？</p><ul><li>生成环境不需要安装时，我们需要通过 <code>npm install --production</code> 来安装文件的依赖；</li></ul><p><strong>版本管理的问题</strong></p><p>我们会发现安装的依赖版本出现：<code>^2.0.3</code>或<code>~2.0.3</code>，这是什么意思呢？</p><p>npm的包通常需要遵从semver版本规范：</p><ul><li>semver：<a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></li><li>npm semver：<a href="https://docs.npmjs.com/misc/semver">https://docs.npmjs.com/misc/semver</a></li></ul><p>semver版本规范是X.Y.Z：</p><ul><li>X主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本）；</li><li>Y次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；</li><li>Z修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；</li></ul><p>我们这里解释一下 ^和~的区别：</p><ul><li><code>^x.y.z</code>：表示x是保持不变的，y和z永远安装最新的版本；</li><li><code>~x.y.z</code>：表示x和y保持不变的，z永远安装最新的版本；</li></ul><p><strong>engines属性</strong></p><ul><li>engines属性用于指定Node和NPM的版本号；</li><li>在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；</li><li>事实上也可以指定所在的操作系统 <code>&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ]</code>，只是很少用到；</li></ul><p><strong>browserslist属性</strong></p><ul><li>用于配置打包后的JavaScript浏览器的兼容情况，参考；</li><li>否则我们需要手动的添加polyfills来让支持某些语法；</li><li>也就是说它是为webpack等打包工具服务的一个属性（这里不是详细讲解webpack等工具的工作原理，所以不再给出详情）；</li></ul><h2 id="二-npm工具解析"><a href="#二-npm工具解析" class="headerlink" title="二. npm工具解析"></a>二. npm工具解析</h2><h3 id="2-1-npm-install命令"><a href="#2-1-npm-install命令" class="headerlink" title="2.1. npm install命令"></a>2.1. npm install命令</h3><p>安装npm包分两种情况：</p><ul><li>全局安装（global install）：<code>npm install yarn -g</code>;</li><li>项目（局部）安装（local install）：<code>npm install</code></li></ul><p><strong>全局安装</strong></p><p>全局安装是直接将某个包安装到全局：</p><p>比如yarn的全局安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm install yarn -g</span><br></pre></td></tr></table></figure><p>但是很多人对全局安装有一些误会：</p><ul><li>通常使用npm全局安装的包都是一些工具包：yarn、webpack等；</li><li>并不是类似于 axios、express、koa等库文件；</li><li>所以全局安装了之后并不能让我们在所有的项目中使用 axios等库；</li></ul><p><strong>项目安装</strong></p><p>项目安装会在当前目录下生产一个 <code>node_modules</code> 文件夹，我们之前讲解require查找顺序时有讲解过这个包在什么情况下被查找；</p><p>局部安装分为开发时依赖和生产时依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line"># 安装开发和生产依赖</span><br><span class="line">npm install axios --save</span><br><span class="line">npm install axios -S</span><br><span class="line">npm install axios</span><br><span class="line">npm i axios</span><br><span class="line"></span><br><span class="line"># 开发者</span><br><span class="line">npm install axios --save-dev</span><br><span class="line">npm install axios -D</span><br><span class="line">npm i axios -D</span><br></pre></td></tr></table></figure><h3 id="2-2-npm-install原理"><a href="#2-2-npm-install原理" class="headerlink" title="2.2. npm install原理"></a>2.2. npm install原理</h3><p>很多同学之情应该已经会了 <code>npm install &lt;package&gt;</code>，但是你是否思考过它的内部原理呢？</p><ul><li>执行 <code>npm install</code>它背后帮助我们完成了什么操作？</li><li>我们会发现还有一个成为package-lock.json的文件，它的作用是什么？</li><li>从npm5开始，npm支持缓存策略（来自yarn的压力），缓存有什么作用呢？</li></ul><p>这是一幅我画出的根据 <code>npm install</code> 的原理图：</p><ul><li>npm install会检测是有package-lock.json文件：</li><li><ul><li>检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）；</li><li>一致的情况下，会去优先查找缓存</li><li>查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中；</li><li>不一致，那么会重新构建依赖关系，直接会走顶层的流程；</li><li>没有找到，会从registry仓库下载，直接走顶层流程；</li><li>分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况；</li><li>从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；</li><li>获取到压缩包后会对压缩包进行缓存（从npm5开始有的）；</li><li>将压缩包解压到项目的node_modules文件夹中（前面我们讲过，require的查找顺序会在该包下面查找）</li><li>没有lock文件</li><li>有lock文件</li></ul></li></ul><p>package-lock.json文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;learn-npm&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;lockfileVersion&quot;: 1,</span><br><span class="line">  &quot;requires&quot;: true,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;axios&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;0.20.0&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;axios&#x2F;-&#x2F;axios-0.20.0.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha512-ANA4rr2BDcmmAQLOKft2fufrtuvlqR+cXNNinUmvfeSNCOF98PZL+7M&#x2F;v1zIdGo7OLjEA9J2gXJL+j4zGsl0bA&#x3D;&#x3D;&quot;,</span><br><span class="line">      &quot;requires&quot;: &#123;</span><br><span class="line">        &quot;follow-redirects&quot;: &quot;^1.10.0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;follow-redirects&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;1.13.0&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;follow-redirects&#x2F;-&#x2F;follow-redirects-1.13.0.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha512-aq6gF1BEKje4a9i9+5jimNFIpq4Q1WiwBToeRK5NvZBd&#x2F;TRsmW8BsJfOEGkr76TbOyPVD3OVDN910EcUNtRYEA&#x3D;&#x3D;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package-lock.json文件解析：</p><ul><li>name：项目的名称；</li><li>version：项目的版本；</li><li>lockfileVersion：lock文件的版本；</li><li>requires：使用requires来跟着模块的依赖关系；</li><li>dependencies：项目的依赖</li><li><ul><li>version表示实际安装的axios的版本；</li><li>resolved用来记录下载的地址，registry仓库中的位置；</li><li>requires记录当前模块的依赖；</li><li>integrity用来从缓存中获取索引，再通过索引去获取压缩包文件；</li><li>当前项目依赖axios，但是axios依赖follow-redireacts；</li><li>axios中的属性如下：</li></ul></li></ul><h3 id="2-3-其他npm命令"><a href="#2-3-其他npm命令" class="headerlink" title="2.3. 其他npm命令"></a>2.3. 其他npm命令</h3><p>我们这里再介绍几个比较常用的：</p><p>卸载某个依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm uninstall package</span><br><span class="line">npm uninstall package --save-dev</span><br><span class="line">npm uninstall package -D</span><br></pre></td></tr></table></figure><p>强制重新build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm rebuild</span><br></pre></td></tr></table></figure><p>清除缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm cache clean</span><br></pre></td></tr></table></figure><p>npm的命令其实是非常多的：</p><ul><li><a href="https://docs.npmjs.com/cli-documentation/cli">https://docs.npmjs.com/cli-documentation/cli</a></li><li>更多的命令，可以根据需要查阅官方文档</li></ul><h3 id="2-4-yarn和cnpm"><a href="#2-4-yarn和cnpm" class="headerlink" title="2.4. yarn和cnpm"></a>2.4. yarn和cnpm</h3><p>另一个node包管理工具yarn：</p><ul><li>yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；</li><li>yarn 是为了弥补 npm 的一些缺陷而出现的；</li><li>早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；</li><li>虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；</li></ul><p><strong>补充：cnpm</strong></p><p>由于一些特殊的原因，某些情况下我们没办法很好的从 <code>https://registry.npmjs.org</code>下载下来一些需要的包。</p><p>查看npm镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm config get registry # npm config get registry</span><br></pre></td></tr></table></figure><p>我们可以直接设置npm的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>但是对于大多数人来说（比如我），并不希望将npm镜像修改了：</p><ul><li>第一，不太希望随意修改npm原本从官方下来包的渠道；</li><li>第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；</li></ul><p>这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">cnpm config get registry # https:&#x2F;&#x2F;r.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure><p><strong>补充：npx</strong></p><p>npx是npm5.2之后自带的一个命令。</p><p>npx的作用非常多，但是比较常见的是使用它来调用项目中的某个模块的指令。</p><p>我们以webpack为例：</p><ul><li>全局安装的是webpack5.1.3</li><li>项目安装的是webpack3.6.0</li></ul><p>如果我在终端执行 <code>webpack --version</code>使用的是哪一个命令呢？</p><ul><li>显示结果会是 <code>webpack 5.1.3</code>，事实上使用的是全局的，为什么呢？</li><li>原因非常简单，在当前目录下找不到webpack时，就会去全局找，并且执行命令；</li></ul><p>那么如何使用项目（局部）的webpack，常见的是两种方式：</p><ul><li>方式一：明确查找到node_module下面的webpack</li><li>方式二：在 <code>scripts</code>定义脚本，来执行webpack；</li></ul><p>方式一：在终端中使用如下命令（在项目根目录下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --version</span><br></pre></td></tr></table></figure><p>方式二：修改package.json中的scripts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;webpack&quot;: &quot;webpack --version&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>终端中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npm run webpack</span><br></pre></td></tr></table></figure><p>但是这两种方式都有一点点麻烦，更好的办法是直接使用npx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">npx webpack --version</span><br></pre></td></tr></table></figure><p>npx的原理非常简单，它会到当前目录的node_modules/.bin目录下查找对应的命令；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;npm的初步见解&quot;&gt;&lt;a href=&quot;#npm的初步见解&quot; class=&quot;headerlink&quot; title=&quot;npm的初步见解&quot;&gt;&lt;/a&gt;npm的初步见解&lt;/h2&gt;&lt;h2 id=&quot;一-包管理工具&quot;&gt;&lt;a href=&quot;#一-包管理工具&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript——顺序表、链表</title>
    <link href="http://example.com/2020/01/30/JavaScript%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%E3%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2020/01/30/JavaScript%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%E3%80%81%E9%93%BE%E8%A1%A8/</id>
    <published>2020-01-30T13:10:27.000Z</published>
    <updated>2021-03-12T07:03:33.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序表与链表"><a href="#顺序表与链表" class="headerlink" title="顺序表与链表"></a>顺序表与链表</h3><h4 id="1-顺序表-数组"><a href="#1-顺序表-数组" class="headerlink" title="1. 顺序表(数组)"></a>1. 顺序表(数组)</h4><blockquote><p>顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中</p></blockquote><h5 id="顺序表的优点："><a href="#顺序表的优点：" class="headerlink" title="顺序表的优点："></a>顺序表的优点：</h5><p>存储的数据是连续的，访问数据可以一次定位，时间复杂度为O(1)</p><h5 id="顺序表的缺点："><a href="#顺序表的缺点：" class="headerlink" title="顺序表的缺点："></a>顺序表的缺点：</h5><p>空间必须是连续的，如果要插入新的元素要换内存空间地址，如果内存太小满足不了顺序表的要求，则无法使用</p><h4 id="2-单链表"><a href="#2-单链表" class="headerlink" title="2. 单链表"></a>2. 单链表</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul><li>链表是一种非线性、非顺序的物理结构，是由若干个节点组成。</li><li>链表采用的是“见缝插针”的存储方法，不要求内存连续，靠next指针关联起来。</li><li>链表的物理存储方式为随机存储，访问方式为顺序访问。</li><li>查找节点的时间复杂度为O(n)，插入、删除节点的时间复杂度为O(1)。</li><li>链表适用于写操作多，读操作少的场景。</li></ul><h5 id="顺序表-数组-与单链表对比"><a href="#顺序表-数组-与单链表对比" class="headerlink" title="顺序表(数组)与单链表对比"></a>顺序表(数组)与单链表对比</h5><ul><li>数组静态分配内存，链表动态分配内存；</li><li>数组在内存中连续(查询快)，链表不连续（查询需要从head节点开始遍历）；</li><li>数组元素在栈区，链表元素在堆区;</li><li>数组查询快、增删慢；链表增删快、查询慢</li></ul><h5 id="单链表js实现"><a href="#单链表js实现" class="headerlink" title="单链表js实现"></a>单链表<code>js</code>实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义一个节点</span><br><span class="line"> * 分别存储data和下一个节点的地址next</span><br><span class="line"> * 尾节点指向null 一个节点则next指向null</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.element &#x3D; element;</span><br><span class="line">    this.next &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定义一个链表</span><br><span class="line"> *&#x2F;</span><br><span class="line">class LinkList &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前头节点</span><br><span class="line">    this.head &#x3D; new Node(&#39;head&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 查找某一个元素</span><br><span class="line">  find(item) &#123;</span><br><span class="line">    let currentNode &#x3D; this.head;</span><br><span class="line">    while (currentNode.next !&#x3D;&#x3D; null &amp;&amp; currentNode.element !&#x3D;&#x3D; item) &#123;</span><br><span class="line">      currentNode &#x3D; currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果没有找到则返回最后一个节点 一个节点则是头节点</span><br><span class="line">    return currentNode;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 插入某一个元素</span><br><span class="line">  insert(newitem, item) &#123;</span><br><span class="line">    let newNode &#x3D; new Node(newitem);</span><br><span class="line">    let currentNode &#x3D; this.find(item);</span><br><span class="line">    newNode.next &#x3D; currentNode.next;</span><br><span class="line">    currentNode.next &#x3D; newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 查找某一个节点的前一个结点</span><br><span class="line">  preNode(item) &#123;</span><br><span class="line">    let currentNode &#x3D; this.head;</span><br><span class="line">    while (currentNode.next !&#x3D;&#x3D; null &amp;&amp; currentNode.next.element !&#x3D;&#x3D; item) &#123;</span><br><span class="line">      currentNode &#x3D; currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return currentNode;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 删除一个节点</span><br><span class="line">  remove(item) &#123;</span><br><span class="line">    let preNode &#x3D; this.preNode(item);</span><br><span class="line">    if (!(preNode.next &#x3D;&#x3D;&#x3D; null)) &#123;</span><br><span class="line">      preNode.next &#x3D; preNode.next.next;</span><br><span class="line">      &#x2F;&#x2F; return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; return false;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;修改一个节点</span><br><span class="line">  edit(item, newitem) &#123;</span><br><span class="line">    let node &#x3D; this.find(item);</span><br><span class="line">    node.element &#x3D; newitem;</span><br><span class="line">    &#x2F;&#x2F; return node;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 输出所有节点的值</span><br><span class="line">  display() &#123;</span><br><span class="line">    let currentNode &#x3D; this.head;</span><br><span class="line">    &#x2F;&#x2F; 首先打印头节点的值</span><br><span class="line">    console.log(currentNode.element);</span><br><span class="line">    while (currentNode.next !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      console.log(currentNode.next.element);</span><br><span class="line">      currentNode &#x3D; currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断链表中是否有循环</span><br><span class="line">  hasCircle() &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义两个指针</span><br><span class="line">    let slowPoint &#x3D; this.head;</span><br><span class="line">    let fastPoint &#x3D; this.head;</span><br><span class="line">    while (fastPoint !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      slowPoint &#x3D; slowPoint.next;</span><br><span class="line">      fastPoint &#x3D; fastPoint.next.next;</span><br><span class="line">      if (slowPoint &#x3D;&#x3D;&#x3D; fastPoint) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const linkList &#x3D; new LinkList();</span><br><span class="line"></span><br><span class="line">linkList.insert(&quot;A&quot;);</span><br><span class="line">linkList.insert(&quot;B&quot;);</span><br><span class="line">linkList.insert(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试单项链表是否有循环</span><br><span class="line">linkList.find(&quot;C&quot;).next &#x3D; linkList.find(&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">console.log(linkList.hasCircle()); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; linkList.display();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;顺序表与链表&quot;&gt;&lt;a href=&quot;#顺序表与链表&quot; class=&quot;headerlink&quot; title=&quot;顺序表与链表&quot;&gt;&lt;/a&gt;顺序表与链表&lt;/h3&gt;&lt;h4 id=&quot;1-顺序表-数组&quot;&gt;&lt;a href=&quot;#1-顺序表-数组&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Reack Hook</title>
    <link href="http://example.com/2020/01/20/Reack-Hook/"/>
    <id>http://example.com/2020/01/20/Reack-Hook/</id>
    <published>2020-01-20T13:52:06.000Z</published>
    <updated>2021-03-12T06:48:43.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reack-Hook"><a href="#Reack-Hook" class="headerlink" title="Reack Hook"></a>Reack Hook</h1><h2 id="Hook简介"><a href="#Hook简介" class="headerlink" title="Hook简介"></a>Hook简介</h2><blockquote><p>React 16.7.0开始推行Hook，到 React 16.8.0 Hook 稳定，Hooks开始被推广使用，它解决了传统使用生命周期而导致的相关代码逻辑分离、不相关代码逻辑混合在一个生命周期中、class中复杂的this指向、class不能被很好的压缩、class可能导致热重载不稳定</p></blockquote><blockquote><p>Hook为开发者提供了可以使用function创建微state，且一个state由一个对应的函数管理，还提供了专门处理副作用、实现redux、性能优化等功能，并且100%向后兼容，个人认为Hook是react未来发展的趋势，但并不意味着摒弃class。</p></blockquote><h2 id="Hook-API"><a href="#Hook-API" class="headerlink" title="Hook API"></a>Hook API</h2><h3 id="1、useState"><a href="#1、useState" class="headerlink" title="1、useState"></a>1、useState</h3><blockquote><p>useState返回一个数组，第一个值为state，第二个值为状态管理函数</p><p>值得注意的是：为了使得状态的操作函数 与其他函数区别开且和其对应的状态联系起来，在命名上有如下约定规则： set + 状态名</p><p>如有状态count，则对应状态管理函数命名为 setCount</p></blockquote><p>函数签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [状态名, 状态管理函数] &#x3D; useState(状态初始值);</span><br></pre></td></tr></table></figure><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  &#x2F;&#x2F; 解构赋值获取useState返回的值，并给他们取名为count和setCount</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    </span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态管理函的实参必须有返回值，且此返回值会赋值给对应状态。</p><p>除上述使用形式外，还可以如下使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setCount(()&#x3D;&gt;&#123;</span><br><span class="line">    return count+1;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对应使用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在原有state的基础上改变数据</span><br><span class="line">const [person,setPerson] &#x3D; useState(&#123;</span><br><span class="line">    name: &#39;王老板&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setState( state &#x3D;&gt; (&#123;</span><br><span class="line">    ...person,</span><br><span class="line">    age: ++state.age</span><br><span class="line">&#125;) )</span><br></pre></td></tr></table></figure><p><strong>踩坑记录</strong></p><ul><li><code>useState</code>中的数据务必是<code>immutable</code>数据，若两次传入同一对象则不会触发组件更新，如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;</span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const [list, setList] &#x3D; useState([1, 5, 3, 9])</span><br><span class="line">    return &lt;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;list.map((item, idx) &#x3D;&gt; &lt;li key&#x3D;&#123;String(idx)&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;)&#125;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">        &#123;&#x2F;* sort 不生成副本，直接返回原数组 *&#x2F;&#125;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;()&#x3D;&gt; &#123;setList(list.sort((a, b) &#x3D;&gt; a - b))&#125;&#125;&gt;sort&lt;&#x2F;button&gt;</span><br><span class="line">        &#123;&#x2F;* slice 返回一个新的副本数组 *&#x2F;&#125;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;()&#x3D;&gt; &#123;setList(list.slice().sort((a, b) &#x3D;&gt; a - b))&#125;&#125;&gt;slice&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击sort按钮后并不会出发更新！</p><ul><li><p><code>useState</code>对应的state只要发生改变，无论组件是否使用了<code>state</code>，该组件都会发生更新；</p><p><code>useRef</code>所保存的值，只有在组件中被使用且发生改变时，组件才会更新；</p><p>可以参照两者的区别，根据不同场景来判断使用哪种方式保存数据。</p></li><li><p>useState 是将新值直接覆盖掉旧值，而不是合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [temp,setTemp] &#x3D; useState(&#123;a: 1, b: 2&#125;);</span><br><span class="line">setTemp(&#123;a: 2&#125;); &#x2F;&#x2F; temp &#x3D; &#123;a: 2&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、useEffect"><a href="#2、useEffect" class="headerlink" title="2、useEffect"></a>2、useEffect</h3><blockquote><p>使用<code>useEffect</code>来处理副作用</p></blockquote><p>函数签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1  组件初次渲染后执行一次，依赖项每次改变时执行一次</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;副作用动作</span><br><span class="line">&#125;,[依赖项])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2  组件初次渲染后执行一次</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;副作用动作</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3  组件初次渲染后执行一次，组件每次更新后执行一次</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;副作用动作</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect, useRef &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">export default function Example() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    const [val, setVal] &#x3D; useState(0);</span><br><span class="line">    const num &#x3D; useRef(0);</span><br><span class="line">    useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;1&#39;)</span><br><span class="line">    &#125;,[count]);</span><br><span class="line">    </span><br><span class="line">    useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;2&#39;)</span><br><span class="line">    &#125;,[]);</span><br><span class="line">    </span><br><span class="line">    useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;3&#39;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">    &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count + 1)&#125;&#125;&gt;COUNT&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setVal(val + 1)&#125;&#125;&gt;VAL&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;num.current +&#x3D; 1&#125;&#125;&gt;NUM&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;该组件初次渲染后的执行结果</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击一次 COUNT按钮 后的执行结果</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击一次 VAL按钮 后的执行结果</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击一次 NUM按钮 后的执行结果</span><br></pre></td></tr></table></figure><h4 id="（1）处理无需清除的effect"><a href="#（1）处理无需清除的effect" class="headerlink" title="（1）处理无需清除的effect"></a>（1）处理无需清除的effect</h4><blockquote><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p></blockquote><p>使用实例</p><p> 需求：监听url的变化来发送网络请求，保存返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;</span><br><span class="line">import ajax from &#39;@utils&#x2F;ajax&#39;</span><br><span class="line">export default function Example(&#123; location &#125;) &#123;</span><br><span class="line">    </span><br><span class="line">    const [data, setData] &#x3D; useState(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">        getData();</span><br><span class="line">    &#125;,[location]);</span><br><span class="line">    </span><br><span class="line">    const getData &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        ajax.post().then(res &#x3D;&gt; &#123;</span><br><span class="line">            setData(res);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;div&gt;&#123;data&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当location发生变化时，useEffect中函数就会自动执行</p><h4 id="（2）处理需要清除的effect"><a href="#（2）处理需要清除的effect" class="headerlink" title="（2）处理需要清除的effect"></a>（2）处理需要清除的effect</h4><blockquote><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p></blockquote><p>在useEffect中可选的返回一个清除函数，该清除函数会在组件卸载时自动执行，以达到清除effect的目的</p><p>函数签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;useEffect的第二个参数不影响 ‘清除effect’ 动作</span><br><span class="line">useEffect(()&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;副作用动作</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;清除effect</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">        setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>踩坑记录</strong></p><ul><li>在<code>useEffect</code>和<code>useLayoutEffect</code>中使用<code>async</code>和<code>await</code>语法时，要注意分离<code>async</code>默认返回的<code>promise</code>与<code>useEffect</code>和<code>useLayoutEffect</code>的<code>cleanup</code>函数，不要将<code>async</code>的返回函数返给<code>useEffect</code>。使用<code>IIFE</code>解决</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    (async () &#x3D;&gt; &#123;</span><br><span class="line">        await fetchSomething();</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="3、useMemo与useCallback"><a href="#3、useMemo与useCallback" class="headerlink" title="3、useMemo与useCallback"></a>3、useMemo与useCallback</h3><blockquote><ol><li>当组件state被修改时就会触发组件的重新渲染，无论前后state是否一致</li><li>父组件更新，子组件会自动更新</li><li>组件更新时，会卸载所有function，并重新创建function</li></ol></blockquote><p>这就出现了性能问题，当更新前后状态一致时，是无需更新的。</p><p>在之前使用生命周期时，我们通常的解决方案是调用生命周期钩子函数<code>shouldComponentUpdate</code>来判断新老props、states是否发生变化来决定当前组件是否需要更新（原理可参见 React 的 Diff）</p><p>Hooks出现后，我们可以直接使用function的形式来创建组件状态，但function自身并没有<code>shouldComponentUpdate</code>判断前后状态的能力。并且，每当函数组件被调用都会执行内部的所有的逻辑，其性能损耗显而易见。</p><p><strong>useMemo 与 useCallback 的区别与联系</strong></p><p>实际上<code>useCallback</code>是基于<code>useMemo</code>实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function useCallback(callback, args) &#123;</span><br><span class="line">return useMemo(() &#x3D;&gt; callback, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>useMemo</code>是返回<code>callback</code>执行后的结果</li><li><code>useCallback</code> 是直接返回被<code>useMemo</code>修饰的<code>callback</code>函数</li></ol><h4 id="（1）useMemo"><a href="#（1）useMemo" class="headerlink" title="（1）useMemo"></a>（1）useMemo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default function WithoutMemo() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(1);</span><br><span class="line">    const [val, setValue] &#x3D; useState(&#39;&#39;);</span><br><span class="line"> </span><br><span class="line">    function expensive() &#123;</span><br><span class="line">        console.log(&#39;compute&#39;);</span><br><span class="line">        let sum &#x3D; 0;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; count * 100; i++) &#123;</span><br><span class="line">            sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h4&gt;&#123;count&#125;-&#123;val&#125;-&#123;expensive()&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;+c1&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;input value&#x3D;&#123;val&#125; onChange&#x3D;&#123;event &#x3D;&gt; setValue(event.target.value)&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个组件中含有一个计算量很大的函数<code>expensive</code>，当我们修改 <code>conut</code> <code>val</code>任意一个状态时，<code>expensive</code>都会被触发，尽管<code>val</code>与<code>expensive</code>的计算毫无关系。</p><p>使用<code>useMemo</code>来解决该问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">export default function WithoutMemo() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(1);</span><br><span class="line">    const [val, setValue] &#x3D; useState(&#39;&#39;);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;使用useMemo</span><br><span class="line">    const expensive &#x3D; useMemo(() &#123;</span><br><span class="line">        console.log(&#39;compute&#39;);</span><br><span class="line">        let sum &#x3D; 0;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; count * 100; i++) &#123;</span><br><span class="line">            sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;,[count])</span><br><span class="line">    </span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h4&gt;&#123;count&#125;-&#123;val&#125;-&#123;expensive&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;+c1&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;input value&#x3D;&#123;val&#125; onChange&#x3D;&#123;event &#x3D;&gt; setValue(event.target.value)&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可知，<code>expensive</code>的计算只与count相关，则可使用<code>useMome</code>添加依赖值<code>count</code></p><p>当且仅当count发生有效改变时才会执行相应函数，并返回缓存值给<code>expensive</code></p><h4 id="（2）useCallback"><a href="#（2）useCallback" class="headerlink" title="（2）useCallback"></a>（2）useCallback</h4><p><code>useCallback</code>的特点、作用和用法与<code>useMemo</code>类似，但是他返回一个缓存的函数。</p><p>除了利用<code>useMemo</code>和<code>useCallback</code>的缓存特性以达到 ”减少某函数不必要的计算“ 外，还可以利用这特性实现 “避免子组件不必要的更新”，这里以<code>useCallback</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useCallback, useEffect &#125; from &#39;react&#39;;</span><br><span class="line">function Parent() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(1);</span><br><span class="line">    const [val, setVal] &#x3D; useState(&#39;&#39;);</span><br><span class="line"> </span><br><span class="line">    const callback &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;, [count]);</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h4&gt;&#123;count&#125;- &#123;val&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;Child callback&#x3D;&#123;callback&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function Child(&#123; callback &#125;) &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(() &#x3D;&gt; callback());</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        setCount(callback());</span><br><span class="line">    &#125;, [callback]);</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &#123;count&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中的Child组件中 是依赖于父组件传递来的callback来创建的函数，一旦父组件中的callback发生改变则Child组件就会发生更新，若父组件中的callback不使用useCallback来封装，则父组件中的任意变量发生改变都会导致callback的变化进而导致子组件不必要的更新。</p><p>此外，所有依赖state或props来创建的函数，需要用到缓存函数的地方都是useCallback的使用场景。</p><p><strong>踩坑记录</strong></p><p>使用<code>lodash</code>中的<code>debounced</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;</span><br><span class="line">import &#123; debounce &#125; from &#39;lodash&#39;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [value, setValue] &#x3D; useState(&#39;&#39;);</span><br><span class="line"></span><br><span class="line">    const _debounce &#x3D; debounce((value)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(value)</span><br><span class="line">    &#125;,3000);</span><br><span class="line"></span><br><span class="line">    const _onChange &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">        let value &#x3D; e.target.value;</span><br><span class="line">        setValue(value)</span><br><span class="line">        _debounce(value);</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; onChange&#x3D;&#123;_onChange&#125; value&#x3D;&#123;value&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure><p>每当<code>onChange</code>被触发一次，都会执行<code>setValue</code>，进而导致刷新组件，使得每次都生成新的<code>debounce</code>，这就失去了函数防抖的效果。而此处的矛盾点就是“函数刷新导致生成了新的<code>debounce</code>”，这里就可以使用<code>useCallback</code>来解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useCallback &#125; from &#39;react&#39;</span><br><span class="line">import &#123; debounce &#125; from &#39;lodash&#39;</span><br><span class="line"></span><br><span class="line">const Example &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const [value, setValue] &#x3D; useState(&#39;&#39;);</span><br><span class="line"></span><br><span class="line">    const _debounce &#x3D; useCallback(debounce((value)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;,3000),[]);</span><br><span class="line"></span><br><span class="line">    const _onChange &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">        let value &#x3D; e.target.value;</span><br><span class="line">        setValue(value);</span><br><span class="line">        _debounce(value);</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; onChange&#x3D;&#123;_onChange&#125; value&#x3D;&#123;value&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Example</span><br></pre></td></tr></table></figure><p>这样每次组件刷新后执行的debounce都是同一个函数，进而使得debounce的防抖效果生效。</p><h3 id="4、useContext与useReducer"><a href="#4、useContext与useReducer" class="headerlink" title="4、useContext与useReducer"></a>4、useContext与useReducer</h3><h4 id="（1）useContext"><a href="#（1）useContext" class="headerlink" title="（1）useContext"></a>（1）useContext</h4><blockquote><p>实现同一子树下所有节点可统一共享子树根节点的数据</p></blockquote><p>函数签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value &#x3D; useContext(MyContext);</span><br></pre></td></tr></table></figure><blockquote><p>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p><p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。</p><p>别忘记 <code>useContext</code> 的参数必须是 <em>context 对象本身</em>：</p><ul><li><strong>正确：</strong> <code>useContext(MyContext)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Consumer)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Provider)</code></li></ul><p>调用了 <code>useContext</code> 的组件总会在 context 值变化时重新渲染。</p></blockquote><p>使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useContext &#125; from &#39;react&#39;</span><br><span class="line">&#x2F;&#x2F;创建Context对象，并附默认值 &#123;count: 1&#125;</span><br><span class="line">const MyContext &#x3D; React.createContext(&#123; count: 1 &#125;)</span><br><span class="line">const [count, setState] &#x3D; useState(1)</span><br><span class="line"></span><br><span class="line">export default function Example() &#123;</span><br><span class="line"></span><br><span class="line">    const Son &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;Grandson&gt;&lt;&#x2F;Grandson&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Grandson &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;使用useContext获取Context对象</span><br><span class="line">        const obj &#x3D; useContext(MyContext);</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            Grandson---&#123;obj.count&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;MyContext.Provider value&#x3D;&#123;&#123; count: count &#125;&#125;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; setState(count + 1) &#125;&#125;&gt;ADD&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;Son&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">    &lt;&#x2F;MyContext.Provider&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击按钮改变count时，所有消费者组件都会随之发生更新，这也就达到了跨层级组件直接共享数据的目的。</p><h4 id="（2）useReducer"><a href="#（2）useReducer" class="headerlink" title="（2）useReducer"></a>（2）useReducer</h4><p>函数签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; reducer就是平时redux那种reducer函数</span><br><span class="line">&#x2F;&#x2F; initialState 初始化的state状态</span><br><span class="line">&#x2F;&#x2F; init 一个函数用于惰性计算state初始值</span><br><span class="line">const [state, dispatch] &#x3D; useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（统一管理数据，并对<code>action</code>加以限制）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p></blockquote><p><code>initialArg</code>作为<code>state</code>的初始值，若存在<code>init</code>,则<code>init</code>会将<code>initalArg</code>处理后的值作为<code>state</code>的初始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reducer&#96;对应于&#96;dispatch&#96;,使用dispatch所传入的实参对应于&#96;reducer&#96;的&#96;action</span><br></pre></td></tr></table></figure><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const initialState &#x3D; 0;</span><br><span class="line"></span><br><span class="line">const init &#x3D; (initialCount) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123; count: initialCount &#125;</span><br><span class="line">&#125;</span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123; count: state.count + 1 &#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123; count: state.count - 1 &#125;;</span><br><span class="line">        case &#39;RESET&#39;:</span><br><span class="line">            return init(action.payload)</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState, init);</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        Count: &#123;state.count&#125;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;SUB&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;ADD&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39;, payload: initialState &#125;)&#125;&gt;RESET&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）useContext与useReducer结合使用"><a href="#（3）useContext与useReducer结合使用" class="headerlink" title="（3）useContext与useReducer结合使用"></a>（3）useContext与useReducer结合使用</h4><blockquote><p>结合使用useContext和useReducer以实现共享数据的统一管理和共享数据安全性保证</p></blockquote><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useContext, useReducer &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const MyContext &#x3D; React.createContext(&#123; count: 1 &#125;);</span><br><span class="line"></span><br><span class="line">    const init &#x3D; (initalCount) &#x3D;&gt; &#123;</span><br><span class="line">        return &#123; count: initalCount &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reducer(state, action) &#123;</span><br><span class="line">        switch (action.type) &#123;</span><br><span class="line">            case &#39;increment&#39;:</span><br><span class="line">                return &#123; count: state.count + 1 &#125;;</span><br><span class="line">            case &#39;decrement&#39;:</span><br><span class="line">                return &#123; count: state.count - 1 &#125;;</span><br><span class="line">            case &#39;RESET&#39;:</span><br><span class="line">                return init(action.payload)</span><br><span class="line">            default:</span><br><span class="line">                throw new Error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const initialCount &#x3D; 0;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialCount, init);</span><br><span class="line"></span><br><span class="line">    const Son1 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;Grandson1&gt;&lt;&#x2F;Grandson1&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Son2 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        const obj &#x3D; useContext(MyContext);</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            Son2---&#123;obj.count&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Grandson1 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        const obj &#x3D; useContext(MyContext);</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            Grandson1---&#123;obj.count&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;MyContext.Provider value&#x3D;&#123;&#123; count: state.count &#125;&#125;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;decrement&#39; &#125;)&#125;&gt;SUB&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;ADD&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39;, payload: initialCount &#125;)&#125;&gt;RESET&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;Son1&gt;&lt;&#x2F;Son1&gt;</span><br><span class="line">        &lt;Son2&gt;&lt;&#x2F;Son2&gt;</span><br><span class="line">    &lt;&#x2F;MyContext.Provider&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在已经完成了useContext与useReducer的配合使用，我们现在将代码抽离出来，使其可以在任何组件中都可以快速调用</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-example</span><br><span class="line">-components</span><br><span class="line">-Son</span><br><span class="line">-index.js</span><br><span class="line">-Grandson</span><br><span class="line">-index.js</span><br><span class="line">-store</span><br><span class="line">-index.js</span><br><span class="line">-reducer.js</span><br><span class="line">-index.js</span><br></pre></td></tr></table></figure><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; example\store\index.js</span><br><span class="line">import React, &#123; useReducer, useContext &#125; from &#39;react&#39;</span><br><span class="line">import &#123; defaultState, reducer, init &#125; from &#39;.&#x2F;reducer&#39;</span><br><span class="line"></span><br><span class="line">const MyContext &#x3D; React.createContext();</span><br><span class="line"></span><br><span class="line">const Context &#x3D; props &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将useReducer的返回值 [state,dispatch] 作为参数</span><br><span class="line">    const contextValue &#x3D; useReducer(reducer, defaultState, init);</span><br><span class="line"></span><br><span class="line">    return &lt;MyContext.Provider value&#x3D;&#123;contextValue&#125;&gt;</span><br><span class="line">        &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;MyContext.Provider&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const useMyContext &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    return useContext(MyContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    Context,</span><br><span class="line">    useMyContext</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; example\store\reducer.js</span><br><span class="line">export const defaultState &#x3D; &#123;</span><br><span class="line">    count: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const init &#x3D; (initalState) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123; </span><br><span class="line">        ...initalState,</span><br><span class="line">        count: initalState.count </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const reducer &#x3D; (state, action) &#x3D;&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                count: state.count + 1</span><br><span class="line">            &#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                count: state.count - 1</span><br><span class="line">            &#125;;</span><br><span class="line">        case &#39;RESET&#39;:</span><br><span class="line">            return init(defaultState)</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; example\components\Grandson\index.js</span><br><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123; useMyContext &#125; from &#39;..&#x2F;..&#x2F;store&#39;</span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useMyContext();</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        Grandson --- &#123;state.count&#125;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; dispatch(&#123; type: &#39;increment&#39; &#125;) &#125;&#125;&gt;Grandson ADD&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; dispatch(&#123; type: &#39;decrement&#39; &#125;) &#125;&#125;&gt;Grandson SUB&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; dispatch(&#123; type: &#39;RESET&#39; &#125;) &#125;&#125;&gt;Grandson RESET&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; example\components\Son\index.js</span><br><span class="line">import React from &#39;react&#39;</span><br><span class="line">import Grandson from &#39;..&#x2F;Grandson&#39;</span><br><span class="line"></span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;Grandson&gt;&lt;&#x2F;Grandson&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;example\index.js</span><br><span class="line">import React from &#39;react&#39;</span><br><span class="line">import Son from &#39;.&#x2F;components&#x2F;Son&#39;</span><br><span class="line">import &#123; Context &#125; from &#39;.&#x2F;store&#39;</span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;Context&gt;</span><br><span class="line">        &lt;Son&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">    &lt;&#x2F;Context&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、useRef"><a href="#5、useRef" class="headerlink" title="5、useRef"></a>5、useRef</h3><p>函数签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const refContainer &#x3D; useRef(initialValue);</span><br></pre></td></tr></table></figure><blockquote><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p></blockquote><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const refContainer &#x3D; useRef(null);</span><br><span class="line">    return &lt;div ref&#x3D;&#123;refContainer&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们可以使子组件接受父组件的ref，让父组件有控制组件的能力，这里要借助<code>forwardRef</code></p><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; father</span><br><span class="line">import React, &#123; useRef &#125; from &#39;react&#39;</span><br><span class="line">import Son from &#39;.&#x2F;components&#x2F;Son&#39;</span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const refContainer &#x3D; useRef(null);</span><br><span class="line">    const changeInput &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        refContainer.current.value &#x3D; &#39;啊，我被改了！&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &lt;div &gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;changeInput&#125;&gt;changeInput&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;Son ref&#x3D;&#123;refContainer&#125;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Son</span><br><span class="line">import React, &#123; forwardRef &#125; from &#39;react&#39;</span><br><span class="line">const Son &#x3D; (props,ref) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div &gt;</span><br><span class="line">    &lt;input ref&#x3D;&#123;ref&#125;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">export default forwardRef(Son)</span><br></pre></td></tr></table></figure><p><strong>useRef 声明常量以保存可变值</strong></p><blockquote><p>除了使用useRef绑定DOM，它另一个重要作用就是声明一个常量保存可变值，绕开React的Capture Value特性</p><p>保存常量这一功能实际上是基于useMemo实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; function useRef (initialValue) &#123;</span><br><span class="line">&gt;    return useMemo (() &#x3D;&gt; (&#123; current : initialValue &#125;), []);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可见 就是初始化的时候创建一个<code>&#123;current:initialValue&#125;</code>，不依赖任何数据，需要手动赋值修改</p></blockquote><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef &#125; from &#39;react&#39;</span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const count &#x3D; useRef(0);</span><br><span class="line">    const add &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        count.current +&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &lt;div &gt;</span><br><span class="line">        &lt;h1&gt;&#123;count.current&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;add&#125;&gt;ADD&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>踩坑记录</strong></p><ul><li>注意与useState的区别与联系</li></ul><h3 id="6、useImperativeHandle"><a href="#6、useImperativeHandle" class="headerlink" title="6、useImperativeHandle"></a>6、useImperativeHandle</h3><blockquote><p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用</p></blockquote><p>使用实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;father</span><br><span class="line">import React, &#123; useRef &#125; from &#39;react&#39;</span><br><span class="line">import Son from &#39;.&#x2F;components&#x2F;Son&#39;</span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const refContainer &#x3D; useRef(null);</span><br><span class="line">    const changeInput &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        refContainer.current.focus()</span><br><span class="line">        &#x2F;&#x2F; console.log(refContainer)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &lt;div &gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;changeInput&#125;&gt;changeInput&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;Son ref&#x3D;&#123;refContainer&#125;&gt;&lt;&#x2F;Son&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Son</span><br><span class="line">import React, &#123; useRef, forwardRef, useImperativeHandle &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function Son(props, ref) &#123;</span><br><span class="line">    &#x2F;&#x2F;新建一个ref  将此ref绑定在本组建内的input上</span><br><span class="line">    const inputRef &#x3D; useRef();</span><br><span class="line">    &#x2F;&#x2F;将 使得本组件input获取焦点的方法赋给父组件传递来的ref上 </span><br><span class="line">    useImperativeHandle(ref, () &#x3D;&gt; (&#123;</span><br><span class="line">        focus: () &#x3D;&gt; &#123;</span><br><span class="line">            inputRef.current.focus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default forwardRef(Son);</span><br></pre></td></tr></table></figure><h3 id="7、useLayoutEffect"><a href="#7、useLayoutEffect" class="headerlink" title="7、useLayoutEffect"></a>7、useLayoutEffect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect( () &#x3D;&gt; &#123; &#125;, [ 依赖项 ] );</span><br></pre></td></tr></table></figure><blockquote><p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p><p>尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p></blockquote><h3 id="8、useDebugValue"><a href="#8、useDebugValue" class="headerlink" title="8、useDebugValue"></a>8、useDebugValue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(value)</span><br></pre></td></tr></table></figure><blockquote><p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; function useFriendStatus(friendID) &#123;</span><br><span class="line">&gt;   const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &#x2F;&#x2F; ...</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &#x2F;&#x2F; 在开发者工具中的这个 Hook 旁边显示标签</span><br><span class="line">&gt;   &#x2F;&#x2F; e.g. &quot;FriendStatus: Online&quot;</span><br><span class="line">&gt;   useDebugValue(isOnline ? &#39;Online&#39; : &#39;Offline&#39;);</span><br><span class="line">&gt; </span><br><span class="line">&gt;   return isOnline;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><blockquote><p>在自定义函数中封装原有的Hook</p><p>约定该函数的名称为 <code>use</code>开头</p></blockquote><p>官网案例</p><p>由于<code>isOnline</code>的值是监听网络的结果决定的，则只需要暴露<code>state</code>即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的案例</p><p>当自定义一个Hook，和普通Hook一样使用时，也可以将state对应的操作函数暴露出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;</span><br><span class="line">&#x2F;&#x2F;自定义Hook</span><br><span class="line">export default function useFriendStatus(value) &#123;</span><br><span class="line">    const [isOnline, setIsOnline] &#x3D; useState(value || false);</span><br><span class="line"></span><br><span class="line">    return [isOnline, setIsOnline];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123; useFriendStatus &#125; from &#39;.&#x2F;hooks&#39;;</span><br><span class="line">export default props &#x3D;&gt; &#123;</span><br><span class="line">    const [online, setOnline] &#x3D; useFriendStatus(false);</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &#123;online ? &#39;true&#39; : &#39;false&#39;&#125;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; setOnline(!online) &#125;&#125;&gt;SWITCH&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h2><h3 id="1、只在组件顶层中使用Hook"><a href="#1、只在组件顶层中使用Hook" class="headerlink" title="1、只在组件顶层中使用Hook"></a>1、只在组件顶层中使用Hook</h3><blockquote><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function Example(props) &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0); &#x2F;&#x2F;Yes</span><br><span class="line">    </span><br><span class="line">    if(props.id)&#123;</span><br><span class="line">        &#x2F;&#x2F; const [count, setCount] &#x3D; useState(0); &#x2F;&#x2F;No</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; const [count, setCount] &#x3D; useState(0); &#x2F;&#x2F;No</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、只在React-函数中调用Hook"><a href="#2、只在React-函数中调用Hook" class="headerlink" title="2、只在React 函数中调用Hook"></a>2、只在React 函数中调用Hook</h3><blockquote><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong>你可以：</p><ul><li>在 React 的函数组件中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul><p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p></blockquote><h3 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h3><ol><li>Hook在函数组件中使用（这里不称为 无状态组件），在class组件中是不起作用的</li><li>所有的Hook都是在DOM更新之后执行的</li></ol><h2 id="经验笔记"><a href="#经验笔记" class="headerlink" title="经验笔记"></a>经验笔记</h2><ol><li><p><strong>useState</strong>将函数入参给useState时，该函数是在DOM渲染前执行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [value,setValue] &#x3D; useState(()&#x3D;&gt;&#123;</span><br><span class="line">console.log(&#39;笨鸟先飞&#39;);</span><br><span class="line">return 0</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>useEffect</strong>是在DOM渲染结束后执行的</p></li><li><p><strong>useLayoutEffect</strong>与DOM渲染同步进行，在此函数中获取DOM，会导致偶发性报错</p></li><li><p>组件不要声明在另一个组件内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">const FatherComponent &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">    const SonComponent &#x3D; () &#x3D;&gt; &#123; return &lt;div&gt;&lt;&#x2F;div&gt;&#125;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;SonComponent&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">const SonComponent &#x3D; () &#x3D;&gt; &#123; return &lt;div&gt;&lt;&#x2F;div&gt;&#125;</span><br><span class="line"></span><br><span class="line">const FatherComponent &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;SonComponent&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参照文章："><a href="#参照文章：" class="headerlink" title="参照文章："></a>参照文章：</h2><ol><li><a href="https://react-1251415695.cos-website.ap-chengdu.myqcloud.com/docs/getting-started.html">React官方文档</a></li><li><a href="https://blog.csdn.net/sinat_17775997/article/details/94453167">useMemo与useCallback使用指南</a></li><li><a href="https://blog.csdn.net/gtLBTNq9mr3/article/details/93984397">useReducerde使用和原理</a></li></ol><p>文章还会继续更新完善</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Reack-Hook&quot;&gt;&lt;a href=&quot;#Reack-Hook&quot; class=&quot;headerlink&quot; title=&quot;Reack Hook&quot;&gt;&lt;/a&gt;Reack Hook&lt;/h1&gt;&lt;h2 id=&quot;Hook简介&quot;&gt;&lt;a href=&quot;#Hook简介&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
</feed>
